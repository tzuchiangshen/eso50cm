// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `LogMessage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <LogMessage.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <Ice/LocalException.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

Log::LoggerException::LoggerException(const ::std::string& __ice_message) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(),
#else
    ::Ice::UserException(),
#endif
    message(__ice_message)
{
}

Log::LoggerException::~LoggerException() throw()
{
}

static const char* __Log__LoggerException_name = "Log::LoggerException";

::std::string
Log::LoggerException::ice_name() const
{
    return __Log__LoggerException_name;
}

::Ice::Exception*
Log::LoggerException::ice_clone() const
{
    return new LoggerException(*this);
}

void
Log::LoggerException::ice_throw() const
{
    throw *this;
}

void
Log::LoggerException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::Log::LoggerException"), false);
    __os->startWriteSlice();
    __os->write(message);
    __os->endWriteSlice();
}

void
Log::LoggerException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->read(message);
    __is->endReadSlice();
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Log::LoggerException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Log::LoggerException was not generated with stream support";
    throw ex;
}

void
Log::LoggerException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Log::LoggerException was not generated with stream support";
    throw ex;
}
#endif

struct __F__Log__LoggerException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::Log::LoggerException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__Log__LoggerException__Ptr = new __F__Log__LoggerException;

const ::IceInternal::UserExceptionFactoryPtr&
Log::LoggerException::ice_factory()
{
    return __F__Log__LoggerException__Ptr;
}

class __F__Log__LoggerException__Init
{
public:

    __F__Log__LoggerException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Log::LoggerException", ::Log::LoggerException::ice_factory());
    }

    ~__F__Log__LoggerException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Log::LoggerException");
    }
};

static __F__Log__LoggerException__Init __F__Log__LoggerException__i;

#ifdef __APPLE__
extern "C" { void __F__Log__LoggerException__initializer() {} }
#endif

void
Log::__write(::IceInternal::BasicStream* __os, ::Log::LogLevel v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 7);
}

void
Log::__read(::IceInternal::BasicStream* __is, ::Log::LogLevel& v)
{
    ::Ice::Byte val;
    __is->read(val, 7);
    v = static_cast< ::Log::LogLevel>(val);
}

void
Log::LogMessageData::__write(::IceInternal::BasicStream* __os) const
{
    ::Log::__write(__os, level);
    __os->write(logtimestamp);
    __os->write(timestamp);
    __os->write(source);
    __os->write(data);
    __os->write(method);
    __os->write(lineNumber);
}

void
Log::LogMessageData::__read(::IceInternal::BasicStream* __is)
{
    ::Log::__read(__is, level);
    __is->read(logtimestamp);
    __is->read(timestamp);
    __is->read(source);
    __is->read(data);
    __is->read(method);
    __is->read(lineNumber);
}

void
Log::__writeLogsVector(::IceInternal::BasicStream* __os, const ::Log::LogMessageData* begin, const ::Log::LogMessageData* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
Log::__readLogsVector(::IceInternal::BasicStream* __is, ::Log::LogsVector& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(24, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
Log::LogMessageDataSet::__write(::IceInternal::BasicStream* __os) const
{
    if(logs.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::Log::__writeLogsVector(__os, &logs[0], &logs[0] + logs.size());
    }
    __os->write(firstIndex);
    __os->write(lastIndex);
    __os->write(startTime);
    __os->write(endTime);
}

void
Log::LogMessageDataSet::__read(::IceInternal::BasicStream* __is)
{
    ::Log::__readLogsVector(__is, logs);
    __is->read(firstIndex);
    __is->read(lastIndex);
    __is->read(startTime);
    __is->read(endTime);
}
