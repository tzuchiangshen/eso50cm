CCS PCH C Compiler, Version 4.033, 37980               13-Oct-10 17:17

               Filename: MotorDC_v06.lst

               ROM used: 8188 bytes (50%)
                         Largest free fragment is 8192
               RAM used: 251 (33%) at main() level
                         265 (35%) worst case
               Stack:    3 worst case (1 in main + 2 for interrupts)

*
0000:  GOTO   0B92
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   00B6
0058:  BTFSS  F9D.3
005A:  GOTO   0064
005E:  BTFSC  F9E.3
0060:  GOTO   0102
0064:  BTFSS  FA3.2
0066:  GOTO   0070
006A:  BTFSC  FA4.2
006C:  GOTO   01D8
0070:  MOVFF  0F,00
0074:  MOVFF  10,01
0078:  MOVFF  11,02
007C:  MOVFF  12,03
0080:  MOVFF  13,04
0084:  BSF    0E.7
0086:  MOVFF  0D,FE9
008A:  MOVFF  08,FEA
008E:  MOVFF  09,FE1
0092:  MOVFF  0A,FE2
0096:  MOVFF  0B,FD9
009A:  MOVFF  0C,FDA
009E:  MOVFF  14,FF3
00A2:  MOVFF  15,FF4
00A6:  MOVFF  16,FFA
00AA:  MOVF   05,W
00AC:  MOVFF  07,FE0
00B0:  MOVFF  06,FD8
00B4:  RETFIE 0
.................... /** *************************************************************************** 
....................  
....................  **************************************************************************** */ 
.................... #include "./MotorDC_v06.h" 
.................... #include <18F4431.h> 
.................... //////// Standard Header file for the PIC18F4431 device //////////////// 
.................... #device PIC18F4431 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV27                   //Brownout reset at 2.7V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOWINEN                  //WDT Timer Window Disabled 
.................... #FUSES T1LOWPOWER               //Timer1 low power operation when in sleep 
.................... #FUSES HPOL_HIGH                //High-Side Transistors Polarity is Active-High (PWM 1,3,5 and 7) 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPOL_HIGH                //Low-Side Transistors Polarity is Active-High (PWM 0,2,4 and 6) 
.................... #FUSES PWMPIN                   //PWM outputs disabled upon Reset 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES FLTAC1                   //FLTA input is multiplexed with RC1 
.................... #FUSES SSP_RC                   //SCK/SCL=RC5, SDA/SDI=RC4, SDO=RC7 
.................... #FUSES PWM4D5                   //PWM4 output is multiplexed on RD5 
.................... #FUSES EXCLKC3                  //TMR0/T5CKI external clock input is muliplexed with RC3 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define I2C_ADDRESS 0xA2        //MotorRA 
.................... //#define I2C_ADDRESS 0xA4        //MotorDEC 
....................  
.................... #use delay(clock=20000000) 
.................... #use i2c(Slave,sda=PIN_C4,scl=PIN_C5,address=I2C_ADDRESS) 
....................  
.................... #byte   PORTA = 0xF80 
.................... #byte   PORTB = 0xF81 
.................... #byte   PORTC = 0xF82 
.................... #byte   PORTD = 0xF83 
.................... #byte   PORTE = 0xF84 
....................  
.................... //                           ------------------- 
.................... //           < MCLR |-------| MCLR          RB7 | 
.................... //                          | RA0           RB6 | 
.................... //                          | RA1           RB5 | 
.................... //            | QEI >-------| RA2     P     RB4 |-------| PWM5* > 
.................... //            | QEA >-------| RA3     I     RB3 |-------| PWM3* >  
.................... //            | QEB >-------| RA4     C     RB2 |-------| PWM2  > 
.................... //                          | RA5           RB1 |-------| PWM1* > 
.................... //    (L4)         <|-------| RE0     1     RB0 |-------| PWM0  > 
.................... //    (L5)    < MT0 |-------| RE1     8     Vdd | 
.................... //    (L6)    < MT1 |-------| RE2     F     Vss | 
.................... //                          | Vdd     4     RD7 |-------| PWM7* > 
.................... //                          | Vss     4     RD6 |-------| PWM6  > 
.................... //                          | OSC1    3     RD5 |-------| PWM4  > 
.................... //                          | OSC2    1     RD4 | 
.................... //    (LX)   < TEST |-------| RC0           RC7 | 
.................... //                          | RC1           RC6 | 
.................... //                          | RC2           RC5 |-------< SCL | 
.................... //    (L7)         <|-------| RC3           RC4 |-------< SDA | 
.................... //    (L0)   < TMR0 |-------| RD0           RD3 |-------|>         (L3)  
.................... //    (L1)  < PWMTM |-------| RD1           RD2 |-------|>         (L2)                 
.................... //                           ------------------- 
....................  
.................... //#define FIRMWARE_VERSION "20100406_1607" 
.................... #define rLED PIN_E1 
....................  
.................... //#priority SSP, TIMER0, AD   
....................  
.................... //---------------------------------------------------------------------------- 
.................... #include "./tmr0_18f4431.h" 
.................... //**************************************************************************** 
.................... //                                  T0CON 
.................... //**************************************************************************** 
.................... struct T0CONmap  
.................... { 
....................     unsigned int    T0PS:3;             //Timer0 Prescaler 
....................     BOOLEAN         PSA;                //Timer0 Prescaler assignment bit 
....................     BOOLEAN         T0SE;               //Timer0 Source Edge Select bit 
....................     BOOLEAN         T0CS;               //Timer0 Source Clock Select bit 
....................     BOOLEAN         T016BITS;           //Timer0 16-bits Control bit 
....................     BOOLEAN         TMR0ON;             //Timer0 On/Off Control bit 
.................... } PIC_T0CONbits; 
.................... #byte       PIC_T0CON       = 0xFD5 
.................... #byte       PIC_T0CONbits   = 0xFD5 
....................  
.................... //**************************************************************************** 
.................... //                                  TMR0 
.................... //**************************************************************************** 
.................... #byte       PIC_TMR0L       = 0xFD6 
.................... #byte       PIC_TMR0H       = 0xFD7 
....................  
.................... //int NTmr0; 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Setup Timer0 
.................... //      o                1     
.................... //          Ttmt0 = ( -------- ) * PS * N    ( PS = 2 ) 
.................... //                    (Fosc/4) 
.................... // 
.................... //        donde N es el numero de pasos para que el contador de TMR0 haga  
.................... //        overflow, i.e: ( 0xFFFF - N )   
.................... //      o Para 100[Hz], con Fosc/4 = 5[Mhz] y PS = 2  
.................... //                   
.................... //                    1        (Fosc/4) 
.................... //          N =   --------- * ---------- = 25000 
.................... //                 100[Hz]        PS 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //  Setup Timer0 
.................... //      o   Timero se utiliza para actualizar el DutyCicle de las sen~ales  
.................... //          PWM. 
.................... //      o   El perido total de las sen~al sinusoidal generada es el perido 
.................... //          entre interrucpciones del Timer0 multiplicado por el numero de 
.................... //          entradas de la tabla SINE 
.................... //      o   Con Fosc = 20[MHz] (mas Pre y Post scalers) se tiene que para 
.................... //          generar una sen~al de 60[Hz] es necesario que Timer0 sea 
.................... //          2605 (0xFFFF - 2605) 
.................... //------------------------------------------------------------------------------ 
.................... //void SetupTimer0( void ) 
.................... //{ 
.................... //    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_2); 
.................... //    set_timer0( 0 );                    //ini value for Timer0    
.................... //} 
.................... void SetupTMR0( void ) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL|RTCC_DIV_2); 
*
0286:  MOVLW  80
0288:  MOVWF  FD5
....................     //set_timer0( 40535 );                    //ini value for Timer0 => 100[Hz]    
....................     set_timer0( 0 ); 
028A:  CLRF   FD7
028C:  CLRF   FD6
....................  
....................     //NTmr0 = 100; 
.................... } 
028E:  GOTO   0BE6 (RETURN)
....................  
....................  
....................  
....................  
.................... #include "./i2c_18f4431.h" 
.................... //**************************************************************************** 
.................... //                                  AUXILIAR 
.................... //**************************************************************************** 
.................... #define     I2C_MASK     0x2D 
....................  
.................... //**************************************************************************** 
.................... //                                  SSPBUF 
.................... //**************************************************************************** 
.................... #byte       PIC_SSPBUF      = 0xFC9 
....................  
.................... //**************************************************************************** 
.................... //                                  SSPCON 
.................... //**************************************************************************** 
.................... struct SSPCONmap  
.................... { 
....................     unsigned int    SSPM:4;             //Synchronous Serial Port Mode Select bits 
....................     BOOLEAN         CKP;                //SCK Realese Control bit 
....................     BOOLEAN         SSPEN;              //Synchronous Serial Port Enable bit 
....................     BOOLEAN         SSPOV;              //Receive Overflow Indicator bit, 
....................     BOOLEAN         WCOL;               //Write Collision Detect bit 
.................... } PIC_SSPCONbits; 
.................... #byte       PIC_SSPCON      = 0xFC6 
.................... #byte       PIC_SSPCONbits  = 0xFC6 
....................  
.................... //**************************************************************************** 
.................... //                                  SSPADD 
.................... //**************************************************************************** 
.................... #byte       PIC_SSPADD      = 0xFC8 
....................  
.................... //**************************************************************************** 
.................... //                                  SSPSTAT 
.................... //**************************************************************************** 
.................... struct SSPSTATmap  
.................... { 
....................     BOOLEAN BF;                         //Buffer Full Status bit 
....................     BOOLEAN UA;                         //Update Address (10 bit Salve mode only) 
....................     BOOLEAN R_W;                        //Read/!Write bit information 
....................     BOOLEAN S;                          //Start bit 
....................     BOOLEAN P;                          //Stop bit 
....................     BOOLEAN D_A;                        //Data/!Address bit 
....................     BOOLEAN CKE;                        //SMBus Select bit 
....................     BOOLEAN SMP;                        //Slew Rate Control bit 
.................... } PIC_SSPSTATbits; 
.................... #byte       PIC_SSPSTAT     = 0xFC7 
.................... #byte       PIC_SSPSTATbits = 0xFC7 
....................  
.................... //**************************************************************************** 
.................... //                                  TRISC 
.................... //**************************************************************************** 
.................... struct TRISCmap  
.................... { 
....................     BOOLEAN RC0; 
....................     BOOLEAN RC1; 
....................     BOOLEAN RC2; 
....................     BOOLEAN RC3; 
....................     BOOLEAN RC4;                        //SDA 
....................     BOOLEAN RC5;                        //SCL 
....................     BOOLEAN RC6; 
....................     BOOLEAN RC7; 
.................... } PIC_TRISCbits; 
.................... #byte       PIC_TRISC       = 0xF94 
.................... #byte       PIC_TRISCbits   = 0xF94 
....................  
.................... //---------------------------------------------------------------------------- 
.................... //                                  WriteI2C 
.................... //---------------------------------------------------------------------------- 
.................... int WriteI2C( byte byte_out ) 
.................... { 
....................     PIC_SSPBUF= byte_out; 
*
00E4:  MOVFF  108,FC9
....................     PIC_SSPCONbits.CKP= 1;          //Realease SCL 
00E8:  BSF    FC6.4
....................     if( PIC_SSPCONbits.WCOL )  
00EA:  BTFSS  FC6.7
00EC:  BRA    00F6
....................     { 
....................         return -1; 
00EE:  MOVLW  FF
00F0:  MOVWF  01
00F2:  BRA    0100
....................     } 
....................     else 
00F4:  BRA    0100
....................     { 
....................         while( PIC_SSPSTATbits.BF ); 
00F6:  BTFSC  FC7.0
00F8:  BRA    00F6
....................         return 0; 
00FA:  MOVLW  00
00FC:  MOVWF  01
00FE:  BRA    0100
....................     } 
.................... } 
0100:  RETLW  00
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "./pPWM_18f4431.h" 
.................... //**************************************************************************** 
.................... //                                  OVCOND 
.................... //**************************************************************************** 
.................... #byte       PIC_OVCONS      = 0xF6A 
....................  
.................... //**************************************************************************** 
.................... //                                  OVCOND 
.................... //**************************************************************************** 
.................... #byte       PIC_OVCOND      = 0xF6B 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  Constantes 
.................... #DEFINE     PTMR_1KHz       4095            // Aprox Fpwm = 1[KHz] 
.................... #DEFINE     PTMR_10KHz      500             // Aprox Fpwm = 10[KHz] 
.................... #DEFINE     PTMR_20KHz      250             // Aprox Fpwm = 20[KHz] 
....................      
.................... /** ************************************************************************** 
....................  * 
....................  *  Setup modulos powerPWM 
....................  *      o   Se usan los modulos 0 y 1 para generar dos sen~ales PWM 
....................  *      o   Cada modulo genera, en sus correspondientes pines,  
....................  *          se~nales complementarias 
....................  *      o   Periodo base del ciclo PWM es **250**, que (con Fosc = 20[MHz]  
....................  *          mas Pre y Post scalers), genera una sen~al de 20[KHz] 
....................  *          **250** son 8[bits] lo que implica un PWMduty util de 10[bits], 
....................  *          que es un numero entre 0 (%100 off) y 1023(%100 on) 
....................  * 
....................  *                  ( PTMR + 1 ) x PTMR_PstS 
....................  *      o  Tpwm = ----------------------------- 
....................  *                          Fosc / 4 
....................  * 
....................  */ 
.................... void SetupPowerPWM( void ) { 
....................     setup_power_pwm(  
....................         PWM_CLOCK_DIV_4 |  
....................         PWM_FREE_RUN |  
....................         PWM_DEAD_CLOCK_DIV_4, 
....................         1,                              // postscale 
....................         0,                              // time_base = ini val for PTMR 
....................         PTMR_10KHz,                     // PTPERH PTPERL = pPWM period 
....................         0,                              //compare 
....................         1,                              //compare_postscale 
....................         0                               //dead_time 
....................     ); 
*
0204:  MOVLW  FF
0206:  MOVWF  F6B
0208:  CLRF   F6E
020A:  CLRF   F7F
020C:  MOVLW  80
020E:  MOVWF  F7E
0210:  MOVLW  40
0212:  MOVWF  F6D
0214:  CLRF   F7D
0216:  CLRF   F7C
0218:  MOVLW  F4
021A:  MOVWF  F7B
021C:  MOVLW  01
021E:  MOVWF  F7A
0220:  CLRF   F71
0222:  CLRF   F70
....................     
....................     set_power_pwm0_duty( 0 ); 
0224:  BSF    F6E.1
0226:  CLRF   F79
0228:  CLRF   F78
022A:  BCF    F6E.1
....................     set_power_pwm2_duty( 0 ); 
022C:  BSF    F6E.1
022E:  CLRF   F77
0230:  CLRF   F76
0232:  BCF    F6E.1
....................     set_power_pwm4_duty( 0 ); 
0234:  BSF    F6E.1
0236:  CLRF   F75
0238:  CLRF   F74
023A:  BCF    F6E.1
....................     set_power_pwm6_duty( 0 ); 
023C:  BSF    F6E.1
023E:  CLRF   F73
0240:  CLRF   F72
0242:  BCF    F6E.1
....................      
....................     PIC_OVCONS= 0x00;                   //Valores de los pines en caso de 
0244:  CLRF   F6A
....................                                         //overide cond. (Lo somplementarios  
....................                                         //siguen siendo complentarios)  
....................      
....................     //setup_power_pwm_pins(  
....................     //    PWM_COMPLEMENTARY, 
....................     //    PWM_COMPLEMENTARY, 
....................     //    PWM_COMPLEMENTARY, 
....................     //    PWM_COMPLEMENTARY 
....................     //); 
....................      
....................      
.................... } 
0246:  GOTO   0BDA (RETURN)
....................  
.................... #include "./tmr5_18f4431.h" 
.................... //**************************************************************************** 
.................... //                                  T5CON 
.................... //**************************************************************************** 
.................... struct T5CONmap  
.................... { 
....................     BOOLEAN         TMR5ON;             // Timer 5 On bit 
....................     BOOLEAN         TMR5CS;             // Timer 5 clock source select bit 
....................     BOOLEAN         noT5SYNC;           // Timer 5 external clock input synchronization select bit 
....................     int             T5PS:2;             // Timer 5 input clock prescaler 
....................     BOOLEAN         T5MOD;              // Timer 5 mode bit 
....................     BOOLEAN         noRESEN;            // Special event reset bit 
....................     BOOLEAN         T5SEN;              // Timer 5 sleep enable bit 
.................... } PIC_T5CONbits; 
.................... #byte       PIC_T5CON      = 0xFB7 
.................... #byte       PIC_T5CONbits  = 0xFB7 
....................  
.................... //**************************************************************************** 
.................... //                                  PR5 
.................... //**************************************************************************** 
.................... #byte       PIC_PR5L       = 0xF90 
.................... #byte       PIC_PR5H       = 0xF91 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  SetupTMR5 
.................... //------------------------------------------------------------------------------ 
.................... void SetupTMR5( void ) 
.................... { 
....................     PIC_T5CONbits.TMR5ON   = TRUE;        // On 
....................     PIC_T5CONbits.TMR5CS   = FALSE;       // Internal clock Tcy 
....................     PIC_T5CONbits.noT5SYNC = TRUE;        // no syncronize external clock input 
....................     //PIC_T5CONbits.T5PS     = 0;           // prescaler = 1:1 
....................     PIC_T5CONbits.T5PS     = 1;           // prescaler = 1:2 
....................     //PIC_T5CONbits.T5PS     = 2;           // prescaler = 1:4 
....................     //PIC_T5CONbits.T5PS     = 3;           // prescaler = 1:8 
....................     PIC_T5CONbits.T5MOD    = FALSE;       // continuous mode count 
....................     PIC_T5CONbits.noRESEN  = FALSE;       // special event reset enabled 
....................     PIC_T5CONbits.T5SEN    = FALSE;       // TMR5 disabled during sleep 
....................  
....................     PIC_PR5H = 0xFF; 
....................     PIC_PR5L = 0xFF; 
.................... } 
....................  
.................... #include "./qei_18f4431.h" 
.................... #define     QEI_4X_ResetPERIOD  0x06 
.................... #define     QEI_4X_ResetINDX    0x05 
.................... #define     QEI_2X_ResetPERIOD  0x02 
.................... #define     QEI_2X_ResetINDX    0x01 
.................... #define     QEI_OFF             0x00 
....................  
.................... #define     QEI_RED_1_64        0x03 
.................... #define     QEI_RED_1_16        0x02 
.................... #define     QEI_RED_1_4         0x01 
.................... #define     QEI_RED_1_1         0x00 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  CAP1CON 
.................... struct CAP1CONmap { 
....................     int             CAP1M:4;            // Input capture 1 mode select bits 
....................     BOOLEAN         unused1;            // unimplemented read as 0 
....................     BOOLEAN         unused2;            // unimplemented read as 0 
....................     BOOLEAN         CAP1REN;            // Time Base reset enable bit 
....................     BOOLEAN         unused3; 
.................... } PIC_CAP1CONbits; 
.................... #byte       PIC_CAP1CON      = 0xF63 
.................... #byte       PIC_CAP1CONbits  = 0xF63 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  QEICON 
.................... struct QEICONmap { 
....................     int             PDEC:2;             // Velocity pulse reduction bit 
....................     int             QEIM:3;             // QEI modes bits 
....................     BOOLEAN         UPDOWN;             // Direction of rotation 
....................     BOOLEAN         ERROR;              // QEI error: position counter overflow/underflow 
....................     BOOLEAN         noVELM;             // Velocity mode bit 
.................... } PIC_QEICONbits; 
.................... #byte       PIC_QEICON      = 0xFB6 
.................... #byte       PIC_QEICONbits  = 0xFB6 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  DFLTCON 
.................... struct DFLTCONmap { 
....................     int             FLTCK:3; 
....................     BOOLEAN         FLT1EN; 
....................     BOOLEAN         FLT2EN; 
....................     BOOLEAN         FLT3EN; 
....................     BOOLEAN         FLT4EN; 
....................     BOOLEAN         unused; 
.................... } PIC_DFLTCONbits; 
.................... #byte       PIC_DFLTCON     = 0xF60 
.................... #byte       PIC_DFLTCONbits = 0xF60 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  VREG 
.................... #byte       PIC_VREGH       = 0xF69 
.................... #byte       PIC_VREGL       = 0xF68 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  POSCNT 
.................... #byte       PIC_POSCNTH     = 0xF67 
.................... #byte       PIC_POSCNTL     = 0xF66 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //                                  MAXCNT 
.................... #byte       PIC_MAXCNTH     = 0xF65 
.................... #byte       PIC_MAXCNTL     = 0xF64 
....................  
.................... /** *************************************************************************** 
....................  * Setup QEI 
....................  */   
.................... void SetupQEI( void ) { 
....................     PIC_QEICONbits.noVELM   = TRUE;             // Velocity mode enabled = 0 
024A:  BSF    FB6.7
....................     PIC_QEICONbits.QEIM     = QEI_2X_ResetPERIOD;   
024C:  MOVLW  E3
024E:  ANDWF  FB6,W
0250:  IORLW  08
0252:  MOVWF  FB6
....................     PIC_QEICONbits.PDEC     = QEI_RED_1_1;      // = 1:1 
0254:  MOVLW  FC
0256:  ANDWF  FB6,W
0258:  MOVWF  FB6
....................     //PIC_QEICONbits.PDEC     = QEI_RED_1_4;      // = 1:4 
....................  
....................     //PIC_QEICON = 0b00011000; 
....................  
....................     PIC_MAXCNTH= 0x0B;                      //MAXCNT = 0...3000; 
025A:  MOVLW  0B
025C:  MOVWF  F65
....................     PIC_MAXCNTL= 0xB8;                      //revisar si es 2999 3000 
025E:  MOVLW  B8
0260:  MOVWF  F64
....................  
....................     PIC_DFLTCONbits.FLT4EN  = FALSE; 
0262:  BCF    F60.6
....................     PIC_DFLTCONbits.FLT3EN  = TRUE;         //QEB input 
0264:  BSF    F60.5
....................     PIC_DFLTCONbits.FLT2EN  = TRUE;         //QEA input 
0266:  BSF    F60.4
....................     PIC_DFLTCONbits.FLT1EN  = TRUE;         //INDX input 
0268:  BSF    F60.3
....................     PIC_DFLTCONbits.FLTCK   = 0x00;         //Noise filter clock divider 1:1 
026A:  MOVLW  F8
026C:  ANDWF  F60,W
026E:  MOVWF  F60
....................  
....................     //VEL MODE 
....................     //PIC_CAP1CONbits.CAP1REN = TRUE;         //Reset TMR5 
....................     //PIC_CAP1CONbits.CAP1M   = 15;           //The trigger on every rising edge on CAP1 inp 
....................     PIC_CAP1CONbits.CAP1REN = FALSE;         //Reset TMR5 
0270:  BCF    F63.6
....................     PIC_CAP1CONbits.CAP1M   = 15;           //The trigger on every rising edge on CAP1 inp 
0272:  MOVLW  F0
0274:  ANDWF  F63,W
0276:  IORLW  0F
0278:  MOVWF  F63
....................  
....................  
....................     PIC_POSCNTH= 0; 
027A:  CLRF   F67
....................     PIC_POSCNTL= 0; 
027C:  CLRF   F66
....................     PIC_VREGH  = 0; 
027E:  CLRF   F69
....................     PIC_VREGL  = 0; 
0280:  CLRF   F68
....................  
.................... } 
0282:  GOTO   0BE2 (RETURN)
....................  
.................... //#include "./adc_18f4431.h" 
....................  
.................... //---------------------------------------------------------------------------- 
.................... #define DISABLE     0 
.................... #define ENABLE      1 
.................... #define NEWPID      2 
.................... #define PID         3 
.................... #define NEWRAMPA    4 
.................... #define RAMPA       5 
.................... //#define RESET       6 
.................... #define RESETPID    7 
.................... #define STOP        8 
.................... #define STOPSLOWLY  9 
.................... #define IDLE        255 
....................  
....................  
.................... //---------------------------------------------------------------------------- 
.................... // TMR0: 
.................... int16 tmr0cnt; 
.................... int16 p_tmr0rv; 
.................... int16 p_Tmr0; 
.................... int	  tmr0_flag; 
.................... int	  tmr0_XHz_flag; 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // i2c 
.................... #define buf_len 4 
.................... int i2c_rx_flag; 
.................... int i2c_tx_flag; 
.................... byte i2c_state; 
.................... int buf_idx; 
.................... char buffer[buf_len]; 
.................... int mem_add; 
.................... char i2c_add; 
.................... signed int32 data[8]; 
.................... char * pointer; 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // pPWM 
.................... int             run_flag; 
....................  
....................  
.................... signed int16    p_Vfin; 
.................... int             p_dir; 
....................  
.................... int             m_MtrCtrl;    //1 
.................... signed int16    m_V; 
.................... signed int16    new_V; 
.................... int             m_dir; 
.................... int             new_dir; 
.................... int16           m_NextDuty0; 
.................... int16           m_NextDuty2; 
.................... int16           m_NextDuty4; 
.................... int16           m_NextDuty6; 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // PID 
....................  
.................... float   encTrkVel; 
.................... float   encVelRef; 
.................... float   encVelRef_old; 
.................... float   encVelRef_new; 
.................... float   Vpid; 
....................  
.................... float   error; 
.................... float   derr; 
.................... float	interr; 
.................... float   v_Kp;         //4 
.................... float   v_Ki;         //4 
.................... float   v_Kd;         //4 
....................  
.................... float   h_error; 
.................... float   h_derr; 
.................... float	h_interr; 
.................... float   h_Kp;         //4 
.................... float   h_Ki;         //4 
.................... float   h_Kd;         //4 
....................  
.................... int     h_pid_flag; 
....................  
.................... //Position 
.................... signed int32    trgPos; 
.................... signed int32    trgThreshold; 
.................... signed int32    diffPos; 
.................... int             trgDir; 
.................... int             trgDirOld; 
....................  
.................... float   posError; 
.................... float   trgEncVelRef; 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // QE 
.................... //int old_POSCNTH; 
.................... //int old_POSCNTL; 
.................... signed int32 encRev, encRevOld; 
.................... int16 POSCNT; 
.................... int16 POSCNTold; 
.................... signed int32 encVel, encVelOld; 
.................... signed int32 encVelavg; 
.................... signed int32 encPos, encPosOld; 
....................  
....................  
....................  
....................  
.................... float avg, n_avg; 
....................  
.................... int	  traking_flag; 
.................... int   goto_tracking_flag; 
.................... int   goto_flag; 
.................... /** *************************************************************************** 
....................  * TIMER0_isr 
....................  */ 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  { 
....................     set_timer0( p_Tmr0 ); 
*
00B6:  MOVFF  24,FD7
00BA:  MOVFF  23,FD6
.................... 	tmr0_flag = TRUE; 
00BE:  MOVLW  01
00C0:  MOVWF  25
.................... 	//output_toggle( rLED ); 
.................... 	tmr0cnt --; 
00C2:  MOVF   1F,W
00C4:  BTFSC  FD8.2
00C6:  DECF   20,F
00C8:  DECF   1F,F
.................... 	if( tmr0cnt == 0 ) { 
00CA:  MOVF   1F,F
00CC:  BNZ   00DE
00CE:  MOVF   20,F
00D0:  BNZ   00DE
.................... 		tmr0cnt = p_tmr0rv; 
00D2:  MOVFF  22,20
00D6:  MOVFF  21,1F
.................... 		tmr0_XHz_flag = TRUE; 
00DA:  MOVLW  01
00DC:  MOVWF  26
....................     } 
.................... } 
.................... /** *************************************************************************** 
....................  * SSP_isr 
....................  */ 
00DE:  BCF    FF2.2
00E0:  GOTO   0070
.................... #int_SSP 
.................... void  SSP_isr(void)  { 
....................     
....................     i2c_state = i2c_isr_state(); 
*
0102:  BTFSC  FC7.5
0104:  BRA    010C
0106:  CLRF   xEC
0108:  BTFSC  FC9.0
010A:  BSF    xEC.7
010C:  MOVF   xEC,W
010E:  INCF   xEC,F
0110:  MOVWF  29
.................... 	if( i2c_state == 0 )  { 
0112:  MOVF   29,F
0114:  BNZ   0126
.................... 		buf_idx = 0; 
0116:  CLRF   2A
....................         if( PIC_SSPSTATbits.BF ) { 
0118:  BTFSS  FC7.0
011A:  BRA    0124
....................             i2c_add = i2c_read();               //vacia buffer, lleno con address 
011C:  BTFSS  FC7.0
011E:  BRA    011C
0120:  MOVFF  FC9,30
....................         } 
....................     } else if( i2c_state == 1 ) { 
0124:  BRA    01D2
0126:  DECFSZ 29,W
0128:  BRA    0134
.................... 		mem_add = i2c_read(); 
012A:  BTFSS  FC7.0
012C:  BRA    012A
012E:  MOVFF  FC9,2F
....................     } else if( i2c_state < 5 ) {                   
0132:  BRA    01D2
0134:  MOVF   29,W
0136:  SUBLW  04
0138:  BNC   0164
.................... 		buffer[buf_idx] = i2c_read(); 
013A:  CLRF   03
013C:  MOVF   2A,W
013E:  ADDLW  2B
0140:  MOVWF  FE9
0142:  MOVLW  00
0144:  ADDWFC 03,W
0146:  MOVWF  FEA
0148:  BTFSS  FC7.0
014A:  BRA    0148
014C:  MOVFF  FC9,FEF
.................... 		buf_idx ++; 
0150:  INCF   2A,F
.................... 		buffer[buf_idx]= 0; 
0152:  CLRF   03
0154:  MOVF   2A,W
0156:  ADDLW  2B
0158:  MOVWF  FE9
015A:  MOVLW  00
015C:  ADDWFC 03,W
015E:  MOVWF  FEA
0160:  CLRF   FEF
....................     } else if( i2c_state == 5 ) { 
0162:  BRA    01D2
0164:  MOVF   29,W
0166:  SUBLW  05
0168:  BNZ   0186
.................... 		buffer[buf_idx] = i2c_read(); 
016A:  CLRF   03
016C:  MOVF   2A,W
016E:  ADDLW  2B
0170:  MOVWF  FE9
0172:  MOVLW  00
0174:  ADDWFC 03,W
0176:  MOVWF  FEA
0178:  BTFSS  FC7.0
017A:  BRA    0178
017C:  MOVFF  FC9,FEF
.................... 		i2c_rx_flag = true; 
0180:  MOVLW  01
0182:  MOVWF  27
.................... 	} else if( i2c_state == 0x80 ) {                //Master is requesting data 
0184:  BRA    01D2
0186:  MOVF   29,W
0188:  SUBLW  80
018A:  BNZ   01A0
....................         if( PIC_SSPSTATbits.BF ) { 
018C:  BTFSS  FC7.0
018E:  BRA    0198
....................             i2c_add = i2c_read();               //vacia buffer, lleno con address 
0190:  BTFSS  FC7.0
0192:  BRA    0190
0194:  MOVFF  FC9,30
....................         } 
....................         i2c_tx_flag = TRUE;                         //Prepare data for TX 
0198:  MOVLW  01
019A:  MOVWF  28
.................... 		//pointer = (char *) & data[mem_add]; 
....................         //WriteI2C( pointer[0] ); 
....................         buf_idx= 0; 
019C:  CLRF   2A
....................     } else if( i2c_state < 0x86 ) {                 //Sending  data's last 3 bytes 
019E:  BRA    01D2
01A0:  MOVF   29,W
01A2:  SUBLW  85
01A4:  BNC   01D2
....................         if( buf_idx < 3 ) { 
01A6:  MOVF   2A,W
01A8:  SUBLW  02
01AA:  BNC   01C8
....................             buf_idx ++; 
01AC:  INCF   2A,F
....................             WriteI2C( pointer[buf_idx] ); 
01AE:  CLRF   03
01B0:  MOVF   2A,W
01B2:  ADDWF  51,W
01B4:  MOVWF  FE9
01B6:  MOVF   52,W
01B8:  ADDWFC 03,W
01BA:  MOVWF  FEA
01BC:  MOVFF  FEF,107
01C0:  MOVFF  107,108
01C4:  RCALL  00E4
....................         } else { 
01C6:  BRA    01D2
....................             WriteI2C( '#' ); 
01C8:  MOVLW  23
01CA:  MOVLB  1
01CC:  MOVWF  x08
01CE:  MOVLB  0
01D0:  RCALL  00E4
....................         } 
....................     } 
.................... } 
....................  
.................... /** *************************************************************************** 
....................  * QE Index (event) ISR 
....................  */ 
01D2:  BCF    F9E.3
01D4:  GOTO   0070
.................... #INT_IC2QEI 
.................... void QEIF_isr( void ) { 
....................     //encPERIOD = make16( old_POSCNTH, old_POSCNTL ); 
....................     if( PIC_QEICONbits.UPDOWN ) { 
01D8:  BTFSS  FB6.5
01DA:  BRA    01EE
....................         encRev ++; 
01DC:  MOVLW  01
01DE:  ADDWF  xC1,F
01E0:  BTFSC  FD8.0
01E2:  INCF   xC2,F
01E4:  BTFSC  FD8.2
01E6:  INCF   xC3,F
01E8:  BTFSC  FD8.2
01EA:  INCF   xC4,F
....................     } else { 
01EC:  BRA    01FE
....................         encRev --; 
01EE:  MOVLW  FF
01F0:  ADDWF  xC1,F
01F2:  BTFSS  FD8.0
01F4:  ADDWF  xC2,F
01F6:  BTFSS  FD8.0
01F8:  ADDWF  xC3,F
01FA:  BTFSS  FD8.0
01FC:  ADDWF  xC4,F
....................     } 
.................... } 
....................  
.................... /** *************************************************************************** 
....................  *  UpdatePWMDutyCicles 
....................  *      o   Recalcula los proximos DutyCicles a partir de la frecuencia 
....................  *          Frotor 
....................  */ 
01FE:  BCF    FA4.2
0200:  GOTO   0070
.................... void UpdatePWMDutyCycles( void ) { 
....................     if( m_dir  ) { 
*
09A2:  MOVF   5C,F
09A4:  BZ    09C0
....................         m_NextDuty0 = m_V;                      
09A6:  MOVFF  59,5F
09AA:  MOVFF  58,5E
....................         m_NextDuty2 = 0;  
09AE:  CLRF   x61
09B0:  CLRF   x60
....................         m_NextDuty4 = m_V; 
09B2:  MOVFF  59,63
09B6:  MOVFF  58,62
....................         m_NextDuty6 = 0; 
09BA:  CLRF   x65
09BC:  CLRF   x64
....................     } else { 
09BE:  BRA    09D8
....................         m_NextDuty0 = 0; 
09C0:  CLRF   5F
09C2:  CLRF   5E
....................         m_NextDuty2 = m_V; 
09C4:  MOVFF  59,61
09C8:  MOVFF  58,60
....................         m_NextDuty4 = 0; 
09CC:  CLRF   x63
09CE:  CLRF   x62
....................         m_NextDuty6 = m_V; 
09D0:  MOVFF  59,65
09D4:  MOVFF  58,64
....................     } 
....................     set_power_pwm0_duty( m_NextDuty0 ); 
09D8:  BSF    F6E.1
09DA:  MOVFF  5E,F79
09DE:  MOVFF  5F,F78
09E2:  BCF    F6E.1
....................     set_power_pwm2_duty( m_NextDuty2 ); 
09E4:  BSF    F6E.1
09E6:  MOVFF  60,F77
09EA:  MOVFF  61,F76
09EE:  BCF    F6E.1
....................     set_power_pwm4_duty( m_NextDuty4 ); 
09F0:  BSF    F6E.1
09F2:  MOVFF  62,F75
09F6:  MOVFF  63,F74
09FA:  BCF    F6E.1
....................     set_power_pwm6_duty( m_NextDuty6 ); 
09FC:  BSF    F6E.1
09FE:  MOVFF  64,F73
0A02:  MOVFF  65,F72
0A06:  BCF    F6E.1
.................... } 
0A08:  RETLW  00
....................  
.................... /** *************************************************************************** 
....................  * CalcNextPWMDutyCicles 
....................  *     Para Fpwm = 10KHz, maxDutyCycle ~ 2007 
....................  *     MaxDC = 1800, MinDC = 200; 
....................  *     Si V = 64 => MaxDC = 1800 
....................  */ 
.................... //void CalcNextPWMDutyCicles( void ) { 
.................... //    if( m_dir  ) { 
.................... //        m_NextDuty0 = m_V;                      
.................... //        m_NextDuty2 = 0;  
.................... //        m_NextDuty4 = m_V; 
.................... //        m_NextDuty6 = 0; 
.................... //    } else { 
.................... //        m_NextDuty0 = 0; 
.................... //        m_NextDuty2 = m_V; 
.................... //        m_NextDuty4 = 0; 
.................... //        m_NextDuty6 = m_V; 
.................... //    } 
.................... //} 
....................  
....................  
....................  
.................... /** *************************************************************************** 
....................  * Main 
....................  */ 
.................... void main() 
.................... { 
*
0B92:  CLRF   FF8
0B94:  BCF    FD0.7
0B96:  BSF    0D.7
0B98:  CLRF   FEA
0B9A:  CLRF   FE9
0B9C:  BSF    F94.5
0B9E:  BSF    F94.4
0BA0:  MOVLW  A2
0BA2:  MOVWF  FC8
0BA4:  MOVLW  36
0BA6:  MOVWF  FC6
0BA8:  BCF    FB9.0
0BAA:  BCF    FC1.6
0BAC:  BCF    FC1.7
0BAE:  MOVLW  00
0BB0:  MOVWF  FB8
0BB2:  CLRF   19
0BB4:  CLRF   1A
0BB6:  MOVLW  03
0BB8:  MOVWF  xEC
.................... 	//int pa, pb, pc, pd, tmp; 
.................... 	int i, sec; 
.................... 	signed int32 X32;//, Y32; 
.................... 	float tmp_float; 
....................      
....................     //------------------------------------------------------------------------ 
....................     //                               Setup uCU 
....................     //------------------------------------------------------------------------ 
....................     set_tris_a( 0b00011111 );           //RA0, RA1, QEIndex, QEA, QEB are inputs 
0BBA:  MOVLW  1F
0BBC:  MOVWF  F92
.................... 	//set_tris_b( 0x00 );               //PORTB all outputs 
....................     set_tris_c( 0b00110100 );           //PORTC 4,5,2 inputs 
0BBE:  MOVLW  34
0BC0:  MOVWF  F94
....................     set_tris_d( 0x00 );                 //PORTD all outputs 
0BC2:  MOVLW  00
0BC4:  MOVWF  F95
....................     set_tris_e( 0x00 );                 //PORTE all outputs 
0BC6:  BCF    F96.0
0BC8:  BCF    F96.1
0BCA:  BCF    F96.2
....................   
....................     setup_wdt( WDT_OFF ); 
0BCC:  BCF    FD1.0
....................  
....................     setup_timer_1( T1_DISABLED ); 
0BCE:  CLRF   FCD
....................     setup_timer_2( T2_DISABLED, 0, 1 ); 
0BD0:  MOVWF  FCA
0BD2:  MOVLW  00
0BD4:  MOVWF  FCB
....................      
....................     //------------------------------------------------------------------------ 
....................     // pPWM 
....................     SetupPowerPWM(); 
0BD6:  GOTO   0204
....................     setup_power_pwm_pins( PWM_COMPLEMENTARY,  
....................         PWM_COMPLEMENTARY, 
....................         PWM_COMPLEMENTARY, 
....................         PWM_COMPLEMENTARY );   
0BDA:  MOVLW  50
0BDC:  MOVWF  F6F
....................          
....................     //------------------------------------------------------------------------ 
....................     // QEI 
....................     SetupQEI(); 
0BDE:  GOTO   024A
....................     //SetupTMR5(); 
....................     //SetupADC(); 
....................  
....................     //------------------------------------------------------------------------ 
....................     //  TMR0 Vars;  
....................     SetupTMR0(); 
0BE2:  GOTO   0286
.................... 	p_Tmr0     = 40535;		            // => 100[Hz]  (tmr0  = 0.4us Xtal= 20MHz / 4 / 2 ) 
0BE6:  MOVLW  9E
0BE8:  MOVWF  24
0BEA:  MOVLW  57
0BEC:  MOVWF  23
.................... 	p_tmr0rv   = 10;		            // => 10[Hz] 
0BEE:  CLRF   22
0BF0:  MOVLW  0A
0BF2:  MOVWF  21
.................... 	set_timer0( p_Tmr0 ); 
0BF4:  MOVFF  24,FD7
0BF8:  MOVFF  23,FD6
.................... 	tmr0cnt = p_tmr0rv; 
0BFC:  MOVFF  22,20
0C00:  MOVFF  21,1F
....................  
....................     //------------------------------------------------------------------------ 
....................     //    Enable Interruptions 
....................     enable_interrupts(INT_TIMER0);      // TMR0 
0C04:  BSF    FF2.5
....................     enable_interrupts(INT_SSP);         // I2C 
0C06:  BSF    F9D.3
....................     enable_interrupts(INT_IC2QEI);      // QE Index event interruption 
0C08:  BSF    FA3.2
....................      
....................     //enable_interrupts(INT_CCP1);        // QE Change on position 
....................     //enable_interrupts(INT_IC1);         // Input Capture 1: QEI Mode/Velocity Mode =>  Velocity  Reg Updated 
....................     //enable_interrupts(INT_PWMTB);       // PWM Base Time 
....................     //enable_interrupts(INT_TIMER5); 
....................     //enable_interrupts(INT_AD); 
....................  
....................     enable_interrupts(GLOBAL); 
0C0A:  MOVLW  C0
0C0C:  IORWF  FF2,F
....................  
....................     //------------------------------------------------------------------------ 
....................     //                              Test Loop 
.................... 	i = 10; 
0C0E:  MOVLW  0A
0C10:  MOVWF  xED
.................... 	while( i > 0 ) {  
0C12:  MOVF   xED,F
0C14:  BZ    0C24
.................... 		if( tmr0_XHz_flag )	{ 
0C16:  MOVF   26,F
0C18:  BZ    0C22
....................     		tmr0_XHz_flag = FALSE; 
0C1A:  CLRF   26
.................... 			output_toggle( rLED ); 
0C1C:  BCF    F96.1
0C1E:  BTG    F8D.1
.................... 			i --; 
0C20:  DECF   xED,F
.................... 		} 
.................... 	}	 
0C22:  BRA    0C12
.................... 	output_low( rLED ); 
0C24:  BCF    F96.1
0C26:  BCF    F8D.1
....................  
....................     //------------------------------------------------------------------------ 
....................     //                              Main Loop  
.................... 	tmr0_flag = FALSE; 
0C28:  CLRF   25
....................     tmr0_XHz_flag = FALSE; 
0C2A:  CLRF   26
....................     p_tmr0rv   = 10;		            // => 10[Hz] 
0C2C:  CLRF   22
0C2E:  MOVLW  0A
0C30:  MOVWF  21
....................      
.................... 	i2c_rx_flag = FALSE; 
0C32:  CLRF   27
.................... 	i2c_tx_flag = FALSE; 
0C34:  CLRF   28
.................... 	run_flag = FALSE; 
0C36:  CLRF   53
....................      
....................     m_V = 0; 
0C38:  CLRF   59
0C3A:  CLRF   58
....................     m_MtrCtrl = IDLE; 
0C3C:  MOVLW  FF
0C3E:  MOVWF  57
....................     encRev = 0; 
0C40:  CLRF   xC4
0C42:  CLRF   xC3
0C44:  CLRF   xC2
0C46:  CLRF   xC1
....................     encRevOld = 0; 
0C48:  CLRF   xC8
0C4A:  CLRF   xC7
0C4C:  CLRF   xC6
0C4E:  CLRF   xC5
....................     * ( ( (char *) & POSCNTold ) + 1 ) = PIC_POSCNTH; 
0C50:  CLRF   xF8
0C52:  MOVLW  CB
0C54:  MOVWF  xF7
0C56:  MOVLW  01
0C58:  ADDWF  xF7,W
0C5A:  MOVWF  01
0C5C:  MOVLW  00
0C5E:  ADDWFC xF8,W
0C60:  MOVFF  01,FE9
0C64:  MOVWF  FEA
0C66:  MOVFF  F67,FEF
....................     * ( ( (char *) & POSCNTold ) )     = PIC_POSCNTL; 
0C6A:  CLRF   xF8
0C6C:  MOVLW  CB
0C6E:  MOVWF  FE9
0C70:  MOVFF  F8,FEA
0C74:  MOVFF  F66,FEF
....................     encPosOld  = encRevOld; 
0C78:  MOVFF  C8,E0
0C7C:  MOVFF  C7,DF
0C80:  MOVFF  C6,DE
0C84:  MOVFF  C5,DD
....................     encPosOld *= 3000; 
0C88:  MOVFF  E0,FA
0C8C:  MOVFF  DF,F9
0C90:  MOVFF  DE,F8
0C94:  MOVFF  DD,F7
0C98:  CLRF   xFE
0C9A:  CLRF   xFD
0C9C:  MOVLW  0B
0C9E:  MOVWF  xFC
0CA0:  MOVLW  B8
0CA2:  MOVWF  xFB
0CA4:  CALL   0292
0CA8:  MOVFF  03,E0
0CAC:  MOVFF  02,DF
0CB0:  MOVFF  01,DE
0CB4:  MOVFF  00,DD
.................... 	encPosOld += POSCNTold;    
0CB8:  MOVF   xCB,W
0CBA:  ADDWF  xDD,F
0CBC:  MOVF   xCC,W
0CBE:  ADDWFC xDE,F
0CC0:  MOVLW  00
0CC2:  ADDWFC xDF,F
0CC4:  ADDWFC xE0,F
.................... 	encVelavg = 0; 
0CC6:  CLRF   xD8
0CC8:  CLRF   xD7
0CCA:  CLRF   xD6
0CCC:  CLRF   xD5
.................... 	traking_flag = false; 
0CCE:  CLRF   xE9
.................... 	goto_tracking_flag = false; 
0CD0:  CLRF   xEA
.................... 	goto_flag    = false; 
0CD2:  CLRF   xEB
....................     //------------------------------------------------------------------------ 
....................     // v_PID 
....................     // Valore para empezar a 4Hz 
....................     // v_Kp      = 0.03333; 
....................     // v_Ki      = 0.08; 
....................     // v_Kd      = 0.1; 
....................     v_Kp      = 0.15; 
0CD4:  MOVLW  9A
0CD6:  MOVWF  x89
0CD8:  MOVLW  99
0CDA:  MOVWF  x88
0CDC:  MOVLW  19
0CDE:  MOVWF  x87
0CE0:  MOVLW  7C
0CE2:  MOVWF  x86
....................     v_Ki      = 0.02; 
0CE4:  MOVLW  0A
0CE6:  MOVWF  x8D
0CE8:  MOVLW  D7
0CEA:  MOVWF  x8C
0CEC:  MOVLW  23
0CEE:  MOVWF  x8B
0CF0:  MOVLW  79
0CF2:  MOVWF  x8A
....................     v_Kd      = 0.01; 
0CF4:  MOVLW  0A
0CF6:  MOVWF  x91
0CF8:  MOVLW  D7
0CFA:  MOVWF  x90
0CFC:  MOVLW  23
0CFE:  MOVWF  x8F
0D00:  MOVLW  78
0D02:  MOVWF  x8E
....................  
.................... 	error           = 0; 
0D04:  CLRF   x7D
0D06:  CLRF   x7C
0D08:  CLRF   x7B
0D0A:  CLRF   x7A
.................... 	encVelRef       = 0; 
0D0C:  CLRF   x6D
0D0E:  CLRF   x6C
0D10:  CLRF   x6B
0D12:  CLRF   x6A
.................... 	encVelRef_old   = 0; 
0D14:  CLRF   x71
0D16:  CLRF   x70
0D18:  CLRF   x6F
0D1A:  CLRF   x6E
.................... 	encVelRef_new   = 0; 
0D1C:  CLRF   x75
0D1E:  CLRF   x74
0D20:  CLRF   x73
0D22:  CLRF   x72
.................... 	encVelOld       = 0; 
0D24:  CLRF   xD4
0D26:  CLRF   xD3
0D28:  CLRF   xD2
0D2A:  CLRF   xD1
....................     derr            = 0; 
0D2C:  CLRF   x81
0D2E:  CLRF   x80
0D30:  CLRF   x7F
0D32:  CLRF   x7E
....................     interr          = 0;  
0D34:  CLRF   x85
0D36:  CLRF   x84
0D38:  CLRF   x83
0D3A:  CLRF   x82
....................     encTrkVel       = 600.0;		 
0D3C:  CLRF   x69
0D3E:  CLRF   x68
0D40:  MOVLW  16
0D42:  MOVWF  x67
0D44:  MOVLW  88
0D46:  MOVWF  x66
....................   
....................     //------------------------------------------------------------------------ 
....................     // h_PID 
....................     h_Kp      = 0.0015; 
0D48:  MOVLW  A6
0D4A:  MOVWF  xA1
0D4C:  MOVLW  9B
0D4E:  MOVWF  xA0
0D50:  MOVLW  44
0D52:  MOVWF  x9F
0D54:  MOVLW  75
0D56:  MOVWF  x9E
....................     h_Ki      = 0.0002; 
0D58:  MOVLW  17
0D5A:  MOVWF  xA5
0D5C:  MOVLW  B7
0D5E:  MOVWF  xA4
0D60:  MOVLW  51
0D62:  MOVWF  xA3
0D64:  MOVLW  72
0D66:  MOVWF  xA2
....................     h_Kd      = 0.0001; 
0D68:  MOVLW  17
0D6A:  MOVWF  xA9
0D6C:  MOVLW  B7
0D6E:  MOVWF  xA8
0D70:  MOVLW  51
0D72:  MOVWF  xA7
0D74:  MOVLW  71
0D76:  MOVWF  xA6
....................  
.................... 	h_error      = 0; 
0D78:  CLRF   x95
0D7A:  CLRF   x94
0D7C:  CLRF   x93
0D7E:  CLRF   x92
....................     h_derr       = 0; 
0D80:  CLRF   x99
0D82:  CLRF   x98
0D84:  CLRF   x97
0D86:  CLRF   x96
....................     h_interr     = 0;  
0D88:  CLRF   x9D
0D8A:  CLRF   x9C
0D8C:  CLRF   x9B
0D8E:  CLRF   x9A
....................   
....................     h_pid_flag = false; 
0D90:  CLRF   xAA
....................     //------------------------------------------------------------------------ 
....................     m_dir = 1; 
0D92:  MOVLW  01
0D94:  MOVWF  5C
....................     n_avg = 1; 
0D96:  CLRF   xE8
0D98:  CLRF   xE7
0D9A:  CLRF   xE6
0D9C:  MOVLW  7F
0D9E:  MOVWF  xE5
....................     avg = 0; 
0DA0:  CLRF   xE4
0DA2:  CLRF   xE3
0DA4:  CLRF   xE2
0DA6:  CLRF   xE1
....................     sec = p_tmr0rv; 
0DA8:  MOVFF  21,EE
....................     PIC_POSCNTH = 0; 
0DAC:  CLRF   F67
....................     PIC_POSCNTL = 0; 
0DAE:  CLRF   F66
....................     POSCNT = 0; 
0DB0:  CLRF   xCA
0DB2:  CLRF   xC9
....................     encRev = 0; 
0DB4:  CLRF   xC4
0DB6:  CLRF   xC3
0DB8:  CLRF   xC2
0DBA:  CLRF   xC1
....................     encPos = 0; 
0DBC:  CLRF   xDC
0DBE:  CLRF   xDB
0DC0:  CLRF   xDA
0DC2:  CLRF   xD9
....................     trgPos = 0; 
0DC4:  CLRF   xAE
0DC6:  CLRF   xAD
0DC8:  CLRF   xAC
0DCA:  CLRF   xAB
....................     while( TRUE ){ 
....................         //old_POSCNTL = PIC_POSCNTL; 
....................         //old_POSCNTH = PIC_POSCNTH; 
....................          
.................... 		if( tmr0_XHz_flag ) { 
0DCC:  MOVF   26,F
0DCE:  BTFSC  FD8.2
0DD0:  GOTO   1B8C
.................... 			tmr0_XHz_flag = FALSE; 
0DD4:  CLRF   26
.................... 			 
.................... 			//POSCNT = make16( PIC_POSCNTH, PIC_POSCNTL ); 
.................... 			* ( ( (char *) & POSCNT ) + 1 ) = PIC_POSCNTH; 
0DD6:  CLRF   xF8
0DD8:  MOVLW  C9
0DDA:  MOVWF  xF7
0DDC:  MOVLW  01
0DDE:  ADDWF  xF7,W
0DE0:  MOVWF  01
0DE2:  MOVLW  00
0DE4:  ADDWFC xF8,W
0DE6:  MOVFF  01,FE9
0DEA:  MOVWF  FEA
0DEC:  MOVFF  F67,FEF
.................... 			* ( ( (char *) & POSCNT ) )     = PIC_POSCNTL; 
0DF0:  CLRF   xF8
0DF2:  MOVLW  C9
0DF4:  MOVWF  FE9
0DF6:  MOVFF  F8,FEA
0DFA:  MOVFF  F66,FEF
.................... 		    encPos  = encRev; 
0DFE:  MOVFF  C4,DC
0E02:  MOVFF  C3,DB
0E06:  MOVFF  C2,DA
0E0A:  MOVFF  C1,D9
.................... 		    encPos *= 3000; 
0E0E:  MOVFF  DC,FA
0E12:  MOVFF  DB,F9
0E16:  MOVFF  DA,F8
0E1A:  MOVFF  D9,F7
0E1E:  CLRF   xFE
0E20:  CLRF   xFD
0E22:  MOVLW  0B
0E24:  MOVWF  xFC
0E26:  MOVLW  B8
0E28:  MOVWF  xFB
0E2A:  CALL   0292
0E2E:  MOVFF  03,DC
0E32:  MOVFF  02,DB
0E36:  MOVFF  01,DA
0E3A:  MOVFF  00,D9
.................... 		    encPos += POSCNT; 
0E3E:  MOVF   xC9,W
0E40:  ADDWF  xD9,F
0E42:  MOVF   xCA,W
0E44:  ADDWFC xDA,F
0E46:  MOVLW  00
0E48:  ADDWFC xDB,F
0E4A:  ADDWFC xDC,F
.................... 		    encVel  = encPos; 
0E4C:  MOVFF  DC,D0
0E50:  MOVFF  DB,CF
0E54:  MOVFF  DA,CE
0E58:  MOVFF  D9,CD
.................... 		    encVel -= encPosOld; 
0E5C:  MOVF   xDD,W
0E5E:  SUBWF  xCD,F
0E60:  MOVF   xDE,W
0E62:  SUBWFB xCE,F
0E64:  MOVF   xDF,W
0E66:  SUBWFB xCF,F
0E68:  MOVF   xE0,W
0E6A:  SUBWFB xD0,F
.................... 	        encVel *= 10;               //10Hz 
0E6C:  MOVFF  D0,FA
0E70:  MOVFF  CF,F9
0E74:  MOVFF  CE,F8
0E78:  MOVFF  CD,F7
0E7C:  CLRF   xFE
0E7E:  CLRF   xFD
0E80:  CLRF   xFC
0E82:  MOVLW  0A
0E84:  MOVWF  xFB
0E86:  CALL   0292
0E8A:  MOVFF  03,D0
0E8E:  MOVFF  02,CF
0E92:  MOVFF  01,CE
0E96:  MOVFF  00,CD
.................... 	         
.................... 	        avg = avg * n_avg; 
0E9A:  MOVFF  E4,FA
0E9E:  MOVFF  E3,F9
0EA2:  MOVFF  E2,F8
0EA6:  MOVFF  E1,F7
0EAA:  MOVFF  E8,FE
0EAE:  MOVFF  E7,FD
0EB2:  MOVFF  E6,FC
0EB6:  MOVFF  E5,FB
0EBA:  CALL   02EE
0EBE:  MOVFF  03,E4
0EC2:  MOVFF  02,E3
0EC6:  MOVFF  01,E2
0ECA:  MOVFF  00,E1
.................... 	        avg += (float)encVel; 
0ECE:  MOVFF  D0,FA
0ED2:  MOVFF  CF,F9
0ED6:  MOVFF  CE,F8
0EDA:  MOVFF  CD,F7
0EDE:  CALL   03F8
0EE2:  BCF    FD8.1
0EE4:  MOVFF  E4,FA
0EE8:  MOVFF  E3,F9
0EEC:  MOVFF  E2,F8
0EF0:  MOVFF  E1,F7
0EF4:  MOVFF  03,FE
0EF8:  MOVFF  02,FD
0EFC:  MOVFF  01,FC
0F00:  MOVFF  00,FB
0F04:  CALL   044E
0F08:  MOVFF  03,E4
0F0C:  MOVFF  02,E3
0F10:  MOVFF  01,E2
0F14:  MOVFF  00,E1
.................... 	        n_avg += 1; 
0F18:  BCF    FD8.1
0F1A:  MOVFF  E8,FA
0F1E:  MOVFF  E7,F9
0F22:  MOVFF  E6,F8
0F26:  MOVFF  E5,F7
0F2A:  CLRF   xFE
0F2C:  CLRF   xFD
0F2E:  CLRF   xFC
0F30:  MOVLW  7F
0F32:  MOVWF  xFB
0F34:  CALL   044E
0F38:  MOVFF  03,E8
0F3C:  MOVFF  02,E7
0F40:  MOVFF  01,E6
0F44:  MOVFF  00,E5
.................... 	        avg /= n_avg; 
0F48:  MOVFF  E4,FA
0F4C:  MOVFF  E3,F9
0F50:  MOVFF  E2,F8
0F54:  MOVFF  E1,F7
0F58:  MOVFF  E8,FE
0F5C:  MOVFF  E7,FD
0F60:  MOVFF  E6,FC
0F64:  MOVFF  E5,FB
0F68:  GOTO   071C
0F6C:  MOVFF  03,E4
0F70:  MOVFF  02,E3
0F74:  MOVFF  01,E2
0F78:  MOVFF  00,E1
....................  
....................             if( encVel != 0 ){ 
0F7C:  MOVF   xCD,F
0F7E:  BNZ   0F8C
0F80:  MOVF   xCE,F
0F82:  BNZ   0F8C
0F84:  MOVF   xCF,F
0F86:  BNZ   0F8C
0F88:  MOVF   xD0,F
0F8A:  BZ    0F90
....................                 output_toggle( rLED ); 
0F8C:  BCF    F96.1
0F8E:  BTG    F8D.1
....................             } 
....................              
....................  
....................  	        if( goto_flag == 1 ) { 
0F90:  DECFSZ xEB,W
0F92:  BRA    1232
....................                 if( goto_tracking_flag ) { 
0F94:  MOVF   xEA,F
0F96:  BZ    0FA4
....................                     trgPos += 60; 
0F98:  MOVLW  3C
0F9A:  ADDWF  xAB,F
0F9C:  MOVLW  00
0F9E:  ADDWFC xAC,F
0FA0:  ADDWFC xAD,F
0FA2:  ADDWFC xAE,F
....................                 } 
....................                 if( encPos < trgPos ) { 
0FA4:  BTFSS  xDC.7
0FA6:  BRA    0FAE
0FA8:  BTFSS  xAE.7
0FAA:  BRA    0FD0
0FAC:  BRA    0FB2
0FAE:  BTFSC  xAE.7
0FB0:  BRA    0FEE
0FB2:  MOVF   xDC,W
0FB4:  SUBWF  xAE,W
0FB6:  BNC   0FEE
0FB8:  BNZ   0FD0
0FBA:  MOVF   xDB,W
0FBC:  SUBWF  xAD,W
0FBE:  BNC   0FEE
0FC0:  BNZ   0FD0
0FC2:  MOVF   xDA,W
0FC4:  SUBWF  xAC,W
0FC6:  BNC   0FEE
0FC8:  BNZ   0FD0
0FCA:  MOVF   xAB,W
0FCC:  SUBWF  xD9,W
0FCE:  BC    0FEE
....................   	                trgDir = 1; 
0FD0:  MOVLW  01
0FD2:  MOVWF  xB7
....................   	                diffPos = trgPos - encPos; 
0FD4:  MOVF   xD9,W
0FD6:  SUBWF  xAB,W
0FD8:  MOVWF  xB3
0FDA:  MOVF   xDA,W
0FDC:  SUBWFB xAC,W
0FDE:  MOVWF  xB4
0FE0:  MOVF   xDB,W
0FE2:  SUBWFB xAD,W
0FE4:  MOVWF  xB5
0FE6:  MOVF   xDC,W
0FE8:  SUBWFB xAE,W
0FEA:  MOVWF  xB6
....................   	            } else { 
0FEC:  BRA    1008
....................       	            trgDir = 0; 
0FEE:  CLRF   xB7
....................       	            diffPos = encPos - trgPos; 
0FF0:  MOVF   xAB,W
0FF2:  SUBWF  xD9,W
0FF4:  MOVWF  xB3
0FF6:  MOVF   xAC,W
0FF8:  SUBWFB xDA,W
0FFA:  MOVWF  xB4
0FFC:  MOVF   xAD,W
0FFE:  SUBWFB xDB,W
1000:  MOVWF  xB5
1002:  MOVF   xAE,W
1004:  SUBWFB xDC,W
1006:  MOVWF  xB6
....................       	        } 
....................                 if( diffPos < 19200 ) { 
1008:  BTFSC  xB6.7
100A:  BRA    1020
100C:  MOVF   xB6,F
100E:  BTFSS  FD8.2
1010:  BRA    10FA
1012:  MOVF   xB5,F
1014:  BTFSS  FD8.2
1016:  BRA    10FA
1018:  MOVF   xB4,W
101A:  SUBLW  4A
101C:  BTFSS  FD8.0
101E:  BRA    10FA
....................                     trgThreshold = 25; 
1020:  CLRF   xB2
1022:  CLRF   xB1
1024:  CLRF   xB0
1026:  MOVLW  19
1028:  MOVWF  xAF
....................                     if( diffPos < 50 )  { 
102A:  BTFSC  xB6.7
102C:  BRA    1040
102E:  MOVF   xB6,F
1030:  BNZ   104C
1032:  MOVF   xB5,F
1034:  BNZ   104C
1036:  MOVF   xB4,F
1038:  BNZ   104C
103A:  MOVF   xB3,W
103C:  SUBLW  31
103E:  BNC   104C
....................                         trgEncVelRef = 0; 
1040:  CLRF   xC0
1042:  CLRF   xBF
1044:  CLRF   xBE
1046:  CLRF   xBD
....................                         goto_flag = 0; 
1048:  CLRF   xEB
....................                 	} else if( diffPos < 19200 ) { 
104A:  BRA    10F8
104C:  BTFSC  xB6.7
104E:  BRA    105E
1050:  MOVF   xB6,F
1052:  BNZ   10E8
1054:  MOVF   xB5,F
1056:  BNZ   10E8
1058:  MOVF   xB4,W
105A:  SUBLW  4A
105C:  BNC   10E8
....................                     	trgEncVelRef  = diffPos; 
105E:  MOVFF  B6,FA
1062:  MOVFF  B5,F9
1066:  MOVFF  B4,F8
106A:  MOVFF  B3,F7
106E:  CALL   03F8
1072:  MOVFF  03,C0
1076:  MOVFF  02,BF
107A:  MOVFF  01,BE
107E:  MOVFF  00,BD
....................                     	trgEncVelRef *= 0.5; 
1082:  MOVFF  C0,FA
1086:  MOVFF  BF,F9
108A:  MOVFF  BE,F8
108E:  MOVFF  BD,F7
1092:  CLRF   xFE
1094:  CLRF   xFD
1096:  CLRF   xFC
1098:  MOVLW  7E
109A:  MOVWF  xFB
109C:  CALL   02EE
10A0:  MOVFF  03,C0
10A4:  MOVFF  02,BF
10A8:  MOVFF  01,BE
10AC:  MOVFF  00,BD
....................                     	trgEncVelRef += 600; 
10B0:  BCF    FD8.1
10B2:  MOVFF  C0,FA
10B6:  MOVFF  BF,F9
10BA:  MOVFF  BE,F8
10BE:  MOVFF  BD,F7
10C2:  CLRF   xFE
10C4:  CLRF   xFD
10C6:  MOVLW  16
10C8:  MOVWF  xFC
10CA:  MOVLW  88
10CC:  MOVWF  xFB
10CE:  CALL   044E
10D2:  MOVFF  03,C0
10D6:  MOVFF  02,BF
10DA:  MOVFF  01,BE
10DE:  MOVFF  00,BD
....................                     	goto_flag = 2; 
10E2:  MOVLW  02
10E4:  MOVWF  xEB
....................                   	} else { 
10E6:  BRA    10F8
....................                       	trgEncVelRef  = 9600; 
10E8:  CLRF   xC0
10EA:  CLRF   xBF
10EC:  MOVLW  16
10EE:  MOVWF  xBE
10F0:  MOVLW  8C
10F2:  MOVWF  xBD
....................                       	goto_flag = 2; 
10F4:  MOVLW  02
10F6:  MOVWF  xEB
....................                     } 
....................                 } else { //if( diffPos >= 19200 )  
10F8:  BRA    11CE
....................               	    if( diffPos < 38400 ) { 
10FA:  BTFSC  xB6.7
10FC:  BRA    110C
10FE:  MOVF   xB6,F
1100:  BNZ   1126
1102:  MOVF   xB5,F
1104:  BNZ   1126
1106:  MOVF   xB4,W
1108:  SUBLW  95
110A:  BNC   1126
....................               	        trgEncVelRef = 9600; 
110C:  CLRF   xC0
110E:  CLRF   xBF
1110:  MOVLW  16
1112:  MOVWF  xBE
1114:  MOVLW  8C
1116:  MOVWF  xBD
....................               	        trgThreshold = 9600; 
1118:  CLRF   xB2
111A:  CLRF   xB1
111C:  MOVLW  25
111E:  MOVWF  xB0
1120:  MOVLW  80
1122:  MOVWF  xAF
....................               	    } else if( diffPos < 76800 ) { 
1124:  BRA    11CA
1126:  BTFSC  xB6.7
1128:  BRA    113C
112A:  MOVF   xB6,F
112C:  BNZ   1154
112E:  MOVF   xB5,W
1130:  SUBLW  01
1132:  BNC   1154
1134:  BNZ   113C
1136:  MOVF   xB4,W
1138:  SUBLW  2B
113A:  BNC   1154
....................               	        trgEncVelRef = 19200; 
113C:  CLRF   xC0
113E:  CLRF   xBF
1140:  MOVLW  16
1142:  MOVWF  xBE
1144:  MOVLW  8D
1146:  MOVWF  xBD
....................               	        trgThreshold = 19200; 
1148:  CLRF   xB2
114A:  CLRF   xB1
114C:  MOVLW  4B
114E:  MOVWF  xB0
1150:  CLRF   xAF
....................               	    } else if( diffPos < 153600 ) { 
1152:  BRA    11CA
1154:  BTFSC  xB6.7
1156:  BRA    116A
1158:  MOVF   xB6,F
115A:  BNZ   1182
115C:  MOVF   xB5,W
115E:  SUBLW  02
1160:  BNC   1182
1162:  BNZ   116A
1164:  MOVF   xB4,W
1166:  SUBLW  57
1168:  BNC   1182
....................               	        trgEncVelRef = 38400; 
116A:  CLRF   xC0
116C:  CLRF   xBF
116E:  MOVLW  16
1170:  MOVWF  xBE
1172:  MOVLW  8E
1174:  MOVWF  xBD
....................               	        trgThreshold = 38400; 
1176:  CLRF   xB2
1178:  CLRF   xB1
117A:  MOVLW  96
117C:  MOVWF  xB0
117E:  CLRF   xAF
....................               	    } else if( diffPos < 307200 ) { 
1180:  BRA    11CA
1182:  BTFSC  xB6.7
1184:  BRA    1198
1186:  MOVF   xB6,F
1188:  BNZ   11B2
118A:  MOVF   xB5,W
118C:  SUBLW  04
118E:  BNC   11B2
1190:  BNZ   1198
1192:  MOVF   xB4,W
1194:  SUBLW  AF
1196:  BNC   11B2
....................               	        trgEncVelRef = 76800; 
1198:  CLRF   xC0
119A:  CLRF   xBF
119C:  MOVLW  16
119E:  MOVWF  xBE
11A0:  MOVLW  8F
11A2:  MOVWF  xBD
....................               	        trgThreshold = 76800; 
11A4:  CLRF   xB2
11A6:  MOVLW  01
11A8:  MOVWF  xB1
11AA:  MOVLW  2C
11AC:  MOVWF  xB0
11AE:  CLRF   xAF
....................               	    } else { 
11B0:  BRA    11CA
....................               	        trgEncVelRef = 76800; 
11B2:  CLRF   xC0
11B4:  CLRF   xBF
11B6:  MOVLW  16
11B8:  MOVWF  xBE
11BA:  MOVLW  8F
11BC:  MOVWF  xBD
....................               	        trgThreshold = 76800; 
11BE:  CLRF   xB2
11C0:  MOVLW  01
11C2:  MOVWF  xB1
11C4:  MOVLW  2C
11C6:  MOVWF  xB0
11C8:  CLRF   xAF
....................               	    }  
....................               	    goto_flag = 2; 
11CA:  MOVLW  02
11CC:  MOVWF  xEB
....................                 } 
....................                  
....................                 if( goto_tracking_flag ) { 
11CE:  MOVF   xEA,F
11D0:  BZ    11FC
....................                     if( trgEncVelRef > 4800 ){ 
11D2:  CLRF   xFE
11D4:  CLRF   xFD
11D6:  MOVLW  16
11D8:  MOVWF  xFC
11DA:  MOVLW  8B
11DC:  MOVWF  xFB
11DE:  MOVFF  C0,102
11E2:  MOVFF  BF,101
11E6:  MOVFF  BE,100
11EA:  MOVFF  BD,FF
11EE:  CALL   08FC
11F2:  BNC   11F8
....................                         traking_flag = false; 
11F4:  CLRF   xE9
....................                     } else { 
11F6:  BRA    11FC
....................                         traking_flag = true; 
11F8:  MOVLW  01
11FA:  MOVWF  xE9
....................                     } 
....................                 } 
....................  
....................         	    if( trgDir > 0 ) { 
11FC:  MOVF   xB7,F
11FE:  BZ    1212
....................       	            encVelRef = trgEncVelRef; 
1200:  MOVFF  C0,6D
1204:  MOVFF  BF,6C
1208:  MOVFF  BE,6B
120C:  MOVFF  BD,6A
....................       	        } else { 
1210:  BRA    1224
....................                     encVelRef = -trgEncVelRef; 
1212:  MOVFF  BD,6A
1216:  MOVF   xBE,W
1218:  XORLW  80
121A:  MOVWF  x6B
121C:  MOVFF  BF,6C
1220:  MOVFF  C0,6D
....................                 } 
....................                 trgDirOld = trgDir; 
1224:  MOVFF  B7,B8
....................                 sec = p_tmr0rv; 
1228:  MOVFF  21,EE
....................                  
....................                 m_MtrCtrl = NEWPID; 
122C:  MOVLW  02
122E:  MOVWF  57
....................             } else if( goto_flag == 2 ) { 
1230:  BRA    1312
1232:  MOVF   xEB,W
1234:  SUBLW  02
1236:  BTFSS  FD8.2
1238:  BRA    1312
....................                 if( trgDir ==  1 ) { 
123A:  DECFSZ xB7,W
123C:  BRA    12A8
....................                     if( encPos + trgThreshold > trgPos ) { 
123E:  MOVF   xAF,W
1240:  ADDWF  xD9,W
1242:  MOVWF  xF7
1244:  MOVF   xB0,W
1246:  ADDWFC xDA,W
1248:  MOVWF  xF8
124A:  MOVF   xB1,W
124C:  ADDWFC xDB,W
124E:  MOVWF  xF9
1250:  MOVF   xB2,W
1252:  ADDWFC xDC,W
1254:  MOVWF  xFA
1256:  BTFSS  xAE.7
1258:  BRA    1260
125A:  BTFSS  xFA.7
125C:  BRA    1282
125E:  BRA    1264
1260:  BTFSC  xFA.7
1262:  BRA    129E
1264:  MOVF   xAE,W
1266:  SUBWF  xFA,W
1268:  BNC   129E
126A:  BNZ   1282
126C:  MOVF   xAD,W
126E:  SUBWF  xF9,W
1270:  BNC   129E
1272:  BNZ   1282
1274:  MOVF   xAC,W
1276:  SUBWF  xF8,W
1278:  BNC   129E
127A:  BNZ   1282
127C:  MOVF   xF7,W
127E:  SUBWF  xAB,W
1280:  BC    129E
....................                         encVelRef = 0; 
1282:  CLRF   x6D
1284:  CLRF   x6C
1286:  CLRF   x6B
1288:  CLRF   x6A
....................                         if( traking_flag ) { 
128A:  MOVF   xE9,F
128C:  BZ    1294
....................                             goto_flag = 1; 
128E:  MOVLW  01
1290:  MOVWF  xEB
....................                         } else { 
1292:  BRA    1298
....................                             goto_flag = 3; 
1294:  MOVLW  03
1296:  MOVWF  xEB
....................                         } 
....................                         m_MtrCtrl = NEWPID; 
1298:  MOVLW  02
129A:  MOVWF  57
....................                     } else { 
129C:  BRA    12A6
....................                         if( sec == 0 ) { 
129E:  MOVF   xEE,F
12A0:  BNZ   12A6
....................                             goto_flag = 1; 
12A2:  MOVLW  01
12A4:  MOVWF  xEB
....................   	                    } 
....................   	                }                 
....................                 } else { //if( trgDir !=  1 ) 
12A6:  BRA    1310
....................                     if( encPos < trgPos + trgThreshold  ) { 
12A8:  MOVF   xAF,W
12AA:  ADDWF  xAB,W
12AC:  MOVWF  00
12AE:  MOVF   xB0,W
12B0:  ADDWFC xAC,W
12B2:  MOVWF  01
12B4:  MOVF   xB1,W
12B6:  ADDWFC xAD,W
12B8:  MOVWF  02
12BA:  MOVF   xB2,W
12BC:  ADDWFC xAE,W
12BE:  MOVWF  03
12C0:  BTFSS  xDC.7
12C2:  BRA    12CA
12C4:  BTFSS  03.7
12C6:  BRA    12EC
12C8:  BRA    12CE
12CA:  BTFSC  03.7
12CC:  BRA    1308
12CE:  MOVF   xDC,W
12D0:  SUBWF  03,W
12D2:  BNC   1308
12D4:  BNZ   12EC
12D6:  MOVF   xDB,W
12D8:  SUBWF  02,W
12DA:  BNC   1308
12DC:  BNZ   12EC
12DE:  MOVF   xDA,W
12E0:  SUBWF  01,W
12E2:  BNC   1308
12E4:  BNZ   12EC
12E6:  MOVF   00,W
12E8:  SUBWF  xD9,W
12EA:  BC    1308
....................                         encVelRef = 0; 
12EC:  CLRF   x6D
12EE:  CLRF   x6C
12F0:  CLRF   x6B
12F2:  CLRF   x6A
....................                         if( traking_flag ) { 
12F4:  MOVF   xE9,F
12F6:  BZ    12FE
....................                             goto_flag = 1; 
12F8:  MOVLW  01
12FA:  MOVWF  xEB
....................                         } else { 
12FC:  BRA    1302
....................                             goto_flag = 3; 
12FE:  MOVLW  03
1300:  MOVWF  xEB
....................                         } 
....................                         m_MtrCtrl = NEWPID; 
1302:  MOVLW  02
1304:  MOVWF  57
....................                     } else { 
1306:  BRA    1310
....................                         if( sec == 0 ) { 
1308:  MOVF   xEE,F
130A:  BNZ   1310
....................                             goto_flag = 1; 
130C:  MOVLW  01
130E:  MOVWF  xEB
....................                         }                         
....................                     } 
....................                 } 
....................                 sec --; 
1310:  DECF   xEE,F
....................             } 
....................                  
....................  
....................   	         
....................   	         
....................   	         
....................   	         
....................   	         
....................     	    switch( m_MtrCtrl ) { 
1312:  MOVF   57,W
1314:  BZ    1350
1316:  XORLW  01
1318:  BZ    135E
131A:  XORLW  05
131C:  BZ    136E
131E:  XORLW  01
1320:  BZ    1382
1322:  XORLW  02
1324:  BTFSC  FD8.2
1326:  BRA    1402
1328:  XORLW  05
132A:  BTFSC  FD8.2
132C:  BRA    1416
132E:  XORLW  01
1330:  BTFSC  FD8.2
1332:  BRA    1632
1334:  XORLW  0B
1336:  BTFSC  FD8.2
1338:  GOTO   1B0A
133C:  XORLW  01
133E:  BTFSC  FD8.2
1340:  GOTO   1B3A
1344:  XORLW  F6
1346:  BTFSC  FD8.2
1348:  GOTO   1B6A
134C:  GOTO   1B6C
....................                 case DISABLE: 
....................                     setup_power_pwm_pins( PWM_OFF, PWM_OFF, PWM_OFF, PWM_OFF ); 
1350:  CLRF   F6F
....................                      
....................                     m_MtrCtrl = IDLE; 
1352:  MOVLW  FF
1354:  MOVWF  57
....................                     m_V = 0; 
1356:  CLRF   59
1358:  CLRF   58
....................                     break; 
135A:  GOTO   1B6C
....................                 case ENABLE: 
....................                     setup_power_pwm_pins( PWM_COMPLEMENTARY,  
....................                         PWM_COMPLEMENTARY, 
....................                         PWM_COMPLEMENTARY, 
....................                         PWM_COMPLEMENTARY ); 
135E:  MOVLW  50
1360:  MOVWF  F6F
....................                    			 
....................                     m_MtrCtrl = IDLE; 
1362:  MOVLW  FF
1364:  MOVWF  57
....................                     m_V = 0; 
1366:  CLRF   59
1368:  CLRF   58
....................                     break;                     
136A:  GOTO   1B6C
....................                 case NEWRAMPA: 
....................                     if( ! run_flag ) { 
136E:  MOVF   53,F
1370:  BNZ   137A
....................                         run_flag = TRUE; 
1372:  MOVLW  01
1374:  MOVWF  53
....................                         m_V = 0 ; 
1376:  CLRF   59
1378:  CLRF   58
....................                     }                     
....................                     m_MtrCtrl = RAMPA; 
137A:  MOVLW  05
137C:  MOVWF  57
....................                     break; 
137E:  GOTO   1B6C
....................                 case RAMPA: 
....................   			        if( p_dir == m_dir ) { 
1382:  MOVF   5C,W
1384:  SUBWF  56,W
1386:  BNZ   13DA
....................               	        if( m_V - p_Vfin > 10 ){ 
1388:  MOVF   54,W
138A:  SUBWF  58,W
138C:  MOVWF  xF7
138E:  MOVF   55,W
1390:  SUBWFB 59,W
1392:  MOVWF  xF8
1394:  BTFSC  FE8.7
1396:  BRA    13AC
1398:  MOVF   xF8,F
139A:  BNZ   13A2
139C:  MOVF   xF7,W
139E:  SUBLW  0A
13A0:  BC    13AC
....................                   	        m_V -= 20; 
13A2:  MOVLW  14
13A4:  SUBWF  58,F
13A6:  MOVLW  00
13A8:  SUBWFB 59,F
....................         		        } else if(  p_Vfin - m_V > 10 ) { 
13AA:  BRA    13D8
13AC:  MOVF   58,W
13AE:  SUBWF  54,W
13B0:  MOVWF  xF7
13B2:  MOVF   59,W
13B4:  SUBWFB 55,W
13B6:  MOVWF  xF8
13B8:  BTFSC  FE8.7
13BA:  BRA    13D0
13BC:  MOVF   xF8,F
13BE:  BNZ   13C6
13C0:  MOVF   xF7,W
13C2:  SUBLW  0A
13C4:  BC    13D0
....................       	  			        m_V += 20; 
13C6:  MOVLW  14
13C8:  ADDWF  58,F
13CA:  MOVLW  00
13CC:  ADDWFC 59,F
....................       			        } else { 
13CE:  BRA    13D8
....................           			        m_V = p_Vfin; 
13D0:  MOVFF  55,59
13D4:  MOVFF  54,58
....................           			    } 
....................       			    } else { 
13D8:  BRA    13FA
....................       			        if( m_V > 10 ) { 
13DA:  BTFSC  59.7
13DC:  BRA    13F2
13DE:  MOVF   59,F
13E0:  BNZ   13E8
13E2:  MOVF   58,W
13E4:  SUBLW  0A
13E6:  BC    13F2
....................           			        m_V -= 20; 
13E8:  MOVLW  14
13EA:  SUBWF  58,F
13EC:  MOVLW  00
13EE:  SUBWFB 59,F
....................           			    } else { 
13F0:  BRA    13FA
....................               			    m_V = 0; 
13F2:  CLRF   59
13F4:  CLRF   58
....................           			        m_dir = p_dir; 
13F6:  MOVFF  56,5C
....................           			    } 
....................       			    } 
....................           			//CalcNextPWMDutyCicles(); 
....................       		        UpdatePWMDutyCycles();    
13FA:  CALL   09A2
....................  
....................                     break; 
13FE:  GOTO   1B6C
....................                 case RESETPID: 
....................                     //Reset PID Integral Term 
....................                     interr     = 0; 
1402:  CLRF   x85
1404:  CLRF   x84
1406:  CLRF   x83
1408:  CLRF   x82
....................                     h_interr     = 0; 
140A:  CLRF   x9D
140C:  CLRF   x9C
140E:  CLRF   x9B
1410:  CLRF   x9A
....................  
....................                     m_MtrCtrl  = PID;                 
1412:  MOVLW  03
1414:  MOVWF  57
....................                 case NEWPID: 
....................                     tmp_float = encVelRef;       
1416:  MOVFF  6D,F6
141A:  MOVFF  6C,F5
141E:  MOVFF  6B,F4
1422:  MOVFF  6A,F3
....................                     if( traking_flag ) { 
1426:  MOVF   xE9,F
1428:  BZ    1460
....................                         tmp_float += encTrkVel; 
142A:  BCF    FD8.1
142C:  MOVFF  F6,FA
1430:  MOVFF  F5,F9
1434:  MOVFF  F4,F8
1438:  MOVFF  F3,F7
143C:  MOVFF  69,FE
1440:  MOVFF  68,FD
1444:  MOVFF  67,FC
1448:  MOVFF  66,FB
144C:  CALL   044E
1450:  MOVFF  03,F6
1454:  MOVFF  02,F5
1458:  MOVFF  01,F4
145C:  MOVFF  00,F3
....................                     }              
....................                     if( tmp_float == 0 ){ 
1460:  MOVFF  F6,FE
1464:  MOVFF  F5,FD
1468:  MOVFF  F4,FC
146C:  MOVFF  F3,FB
1470:  MOVLB  1
1472:  CLRF   x02
1474:  CLRF   x01
1476:  CLRF   x00
1478:  MOVLB  0
147A:  CLRF   xFF
147C:  CALL   08FC
1480:  BNZ   1492
....................                         if( h_pid_flag ) { 
1482:  MOVF   xAA,F
1484:  BZ    148C
....................                             m_MtrCtrl = STOPSLOWLY; 
1486:  MOVLW  09
1488:  MOVWF  57
....................                         } else { 
148A:  BRA    1490
....................                             m_MtrCtrl = STOP; 
148C:  MOVLW  08
148E:  MOVWF  57
....................                         } 
....................                     } else { 
1490:  BRA    15FE
....................                         if( -10200 <  encVelRef && encVelRef < 10200 ) { 
1492:  CLRF   xFE
1494:  MOVLW  60
1496:  MOVWF  xFD
1498:  MOVLW  9F
149A:  MOVWF  xFC
149C:  MOVLW  8C
149E:  MOVWF  xFB
14A0:  MOVFF  6D,102
14A4:  MOVFF  6C,101
14A8:  MOVFF  6B,100
14AC:  MOVFF  6A,FF
14B0:  CALL   08FC
14B4:  BNC   14E2
14B6:  MOVFF  6D,FE
14BA:  MOVFF  6C,FD
14BE:  MOVFF  6B,FC
14C2:  MOVFF  6A,FB
14C6:  MOVLB  1
14C8:  CLRF   x02
14CA:  MOVLW  60
14CC:  MOVWF  x01
14CE:  MOVLW  1F
14D0:  MOVWF  x00
14D2:  MOVLW  8C
14D4:  MOVLB  0
14D6:  MOVWF  xFF
14D8:  CALL   08FC
14DC:  BNC   14E2
....................                             h_pid_flag = false; 
14DE:  CLRF   xAA
....................                         } else { 
14E0:  BRA    14E6
....................                             h_pid_flag = true; 
14E2:  MOVLW  01
14E4:  MOVWF  xAA
....................                         } 
....................                         if( encVel != 0 ) { 
14E6:  MOVF   xCD,F
14E8:  BNZ   14F8
14EA:  MOVF   xCE,F
14EC:  BNZ   14F8
14EE:  MOVF   xCF,F
14F0:  BNZ   14F8
14F2:  MOVF   xD0,F
14F4:  BTFSC  FD8.2
14F6:  BRA    15FA
....................                             if( encVelRef > encVelRef_old ) { 
14F8:  MOVFF  71,FE
14FC:  MOVFF  70,FD
1500:  MOVFF  6F,FC
1504:  MOVFF  6E,FB
1508:  MOVFF  6D,102
150C:  MOVFF  6C,101
1510:  MOVFF  6B,100
1514:  MOVFF  6A,FF
1518:  CALL   08FC
151C:  BNC   158C
....................                                 if( encVelRef - encVelRef_old > 4800 ) { 
151E:  BSF    FD8.1
1520:  MOVFF  6D,FA
1524:  MOVFF  6C,F9
1528:  MOVFF  6B,F8
152C:  MOVFF  6A,F7
1530:  MOVFF  71,FE
1534:  MOVFF  70,FD
1538:  MOVFF  6F,FC
153C:  MOVFF  6E,FB
1540:  CALL   044E
1544:  MOVFF  00,F7
1548:  MOVFF  01,F8
154C:  MOVFF  02,F9
1550:  MOVFF  03,FA
1554:  CLRF   xFE
1556:  CLRF   xFD
1558:  MOVLW  16
155A:  MOVWF  xFC
155C:  MOVLW  8B
155E:  MOVWF  xFB
1560:  MOVFF  03,102
1564:  MOVFF  02,101
1568:  MOVFF  01,100
156C:  MOVFF  00,FF
1570:  CALL   08FC
1574:  BNC   1586
....................                                     if( h_pid_flag ) { 
1576:  MOVF   xAA,F
1578:  BZ    1580
....................                                         m_MtrCtrl = STOPSLOWLY;  
157A:  MOVLW  09
157C:  MOVWF  57
....................                                     } else { 
157E:  BRA    1584
....................                                         m_MtrCtrl = STOP; 
1580:  MOVLW  08
1582:  MOVWF  57
....................                                     } 
....................                                 } else { 
1584:  BRA    158A
....................                                     m_MtrCtrl = PID; 
1586:  MOVLW  03
1588:  MOVWF  57
....................                                 } 
....................                             } else { 
158A:  BRA    15F8
....................                                 if( encVelRef_old - encVelRef > 4800 ) { 
158C:  BSF    FD8.1
158E:  MOVFF  71,FA
1592:  MOVFF  70,F9
1596:  MOVFF  6F,F8
159A:  MOVFF  6E,F7
159E:  MOVFF  6D,FE
15A2:  MOVFF  6C,FD
15A6:  MOVFF  6B,FC
15AA:  MOVFF  6A,FB
15AE:  CALL   044E
15B2:  MOVFF  00,F7
15B6:  MOVFF  01,F8
15BA:  MOVFF  02,F9
15BE:  MOVFF  03,FA
15C2:  CLRF   xFE
15C4:  CLRF   xFD
15C6:  MOVLW  16
15C8:  MOVWF  xFC
15CA:  MOVLW  8B
15CC:  MOVWF  xFB
15CE:  MOVFF  03,102
15D2:  MOVFF  02,101
15D6:  MOVFF  01,100
15DA:  MOVFF  00,FF
15DE:  CALL   08FC
15E2:  BNC   15F4
....................                                     if( h_pid_flag ) { 
15E4:  MOVF   xAA,F
15E6:  BZ    15EE
....................                                         m_MtrCtrl = STOPSLOWLY;  
15E8:  MOVLW  09
15EA:  MOVWF  57
....................                                     } else { 
15EC:  BRA    15F2
....................                                         m_MtrCtrl = STOP; 
15EE:  MOVLW  08
15F0:  MOVWF  57
....................                                     } 
....................                                 } else { 
15F2:  BRA    15F8
....................                                     m_MtrCtrl = PID; 
15F4:  MOVLW  03
15F6:  MOVWF  57
....................                                 } 
....................                             }       
....................                         } else { 
15F8:  BRA    15FE
....................                             m_MtrCtrl = PID; 
15FA:  MOVLW  03
15FC:  MOVWF  57
....................                         }                          
....................                     } 
....................                     encVelRef_old = encVelRef_new; 
15FE:  MOVFF  75,71
1602:  MOVFF  74,70
1606:  MOVFF  73,6F
160A:  MOVFF  72,6E
....................                     encVelRef_new = tmp_float; 
160E:  MOVFF  F6,75
1612:  MOVFF  F5,74
1616:  MOVFF  F4,73
161A:  MOVFF  F3,72
....................                     avg = 0; 
161E:  CLRF   xE4
1620:  CLRF   xE3
1622:  CLRF   xE2
1624:  CLRF   xE1
....................                     n_avg = 1; 
1626:  CLRF   xE8
1628:  CLRF   xE7
162A:  CLRF   xE6
162C:  MOVLW  7F
162E:  MOVWF  xE5
....................                     break; 
1630:  BRA    1B6C
....................                 case PID: 
....................                     if( h_pid_flag ) { 
1632:  MOVF   xAA,F
1634:  BTFSC  FD8.2
1636:  BRA    17EC
....................             	        h_error  = encVel; 
1638:  MOVFF  D0,FA
163C:  MOVFF  CF,F9
1640:  MOVFF  CE,F8
1644:  MOVFF  CD,F7
1648:  CALL   03F8
164C:  MOVFF  03,95
1650:  MOVFF  02,94
1654:  MOVFF  01,93
1658:  MOVFF  00,92
....................             	        h_error -= encVelRef_new; 
165C:  BSF    FD8.1
165E:  MOVFF  95,FA
1662:  MOVFF  94,F9
1666:  MOVFF  93,F8
166A:  MOVFF  92,F7
166E:  MOVFF  75,FE
1672:  MOVFF  74,FD
1676:  MOVFF  73,FC
167A:  MOVFF  72,FB
167E:  CALL   044E
1682:  MOVFF  03,95
1686:  MOVFF  02,94
168A:  MOVFF  01,93
168E:  MOVFF  00,92
....................             	        h_derr   = encVel - encVelOld; 
1692:  MOVF   xD1,W
1694:  SUBWF  xCD,W
1696:  MOVWF  00
1698:  MOVF   xD2,W
169A:  SUBWFB xCE,W
169C:  MOVWF  01
169E:  MOVF   xD3,W
16A0:  SUBWFB xCF,W
16A2:  MOVWF  02
16A4:  MOVF   xD4,W
16A6:  SUBWFB xD0,W
16A8:  MOVWF  03
16AA:  MOVWF  xFA
16AC:  MOVFF  02,F9
16B0:  MOVFF  01,F8
16B4:  MOVFF  00,F7
16B8:  CALL   03F8
16BC:  MOVFF  03,99
16C0:  MOVFF  02,98
16C4:  MOVFF  01,97
16C8:  MOVFF  00,96
....................             	         
....................             	        Vpid  = h_interr + h_error; 
16CC:  BCF    FD8.1
16CE:  MOVFF  9D,FA
16D2:  MOVFF  9C,F9
16D6:  MOVFF  9B,F8
16DA:  MOVFF  9A,F7
16DE:  MOVFF  95,FE
16E2:  MOVFF  94,FD
16E6:  MOVFF  93,FC
16EA:  MOVFF  92,FB
16EE:  CALL   044E
16F2:  MOVFF  03,79
16F6:  MOVFF  02,78
16FA:  MOVFF  01,77
16FE:  MOVFF  00,76
....................             	        Vpid *= h_Ki; 
1702:  MOVFF  79,FA
1706:  MOVFF  78,F9
170A:  MOVFF  77,F8
170E:  MOVFF  76,F7
1712:  MOVFF  A5,FE
1716:  MOVFF  A4,FD
171A:  MOVFF  A3,FC
171E:  MOVFF  A2,FB
1722:  CALL   02EE
1726:  MOVFF  03,79
172A:  MOVFF  02,78
172E:  MOVFF  01,77
1732:  MOVFF  00,76
....................             	        Vpid += h_Kp * h_error; 
1736:  MOVFF  A1,FA
173A:  MOVFF  A0,F9
173E:  MOVFF  9F,F8
1742:  MOVFF  9E,F7
1746:  MOVFF  95,FE
174A:  MOVFF  94,FD
174E:  MOVFF  93,FC
1752:  MOVFF  92,FB
1756:  CALL   02EE
175A:  BCF    FD8.1
175C:  MOVFF  79,FA
1760:  MOVFF  78,F9
1764:  MOVFF  77,F8
1768:  MOVFF  76,F7
176C:  MOVFF  03,FE
1770:  MOVFF  02,FD
1774:  MOVFF  01,FC
1778:  MOVFF  00,FB
177C:  CALL   044E
1780:  MOVFF  03,79
1784:  MOVFF  02,78
1788:  MOVFF  01,77
178C:  MOVFF  00,76
....................                	        Vpid += h_Kd * h_derr; 
1790:  MOVFF  A9,FA
1794:  MOVFF  A8,F9
1798:  MOVFF  A7,F8
179C:  MOVFF  A6,F7
17A0:  MOVFF  99,FE
17A4:  MOVFF  98,FD
17A8:  MOVFF  97,FC
17AC:  MOVFF  96,FB
17B0:  CALL   02EE
17B4:  BCF    FD8.1
17B6:  MOVFF  79,FA
17BA:  MOVFF  78,F9
17BE:  MOVFF  77,F8
17C2:  MOVFF  76,F7
17C6:  MOVFF  03,FE
17CA:  MOVFF  02,FD
17CE:  MOVFF  01,FC
17D2:  MOVFF  00,FB
17D6:  CALL   044E
17DA:  MOVFF  03,79
17DE:  MOVFF  02,78
17E2:  MOVFF  01,77
17E6:  MOVFF  00,76
....................                     } else {   
17EA:  BRA    199E
....................       	                //Vel Tracking = 3000/5 [tics/s] = 600 [tics/s] 
....................           	            error  = encVel; 
17EC:  MOVFF  D0,FA
17F0:  MOVFF  CF,F9
17F4:  MOVFF  CE,F8
17F8:  MOVFF  CD,F7
17FC:  CALL   03F8
1800:  MOVFF  03,7D
1804:  MOVFF  02,7C
1808:  MOVFF  01,7B
180C:  MOVFF  00,7A
....................       	                error -= encVelRef_new; 
1810:  BSF    FD8.1
1812:  MOVFF  7D,FA
1816:  MOVFF  7C,F9
181A:  MOVFF  7B,F8
181E:  MOVFF  7A,F7
1822:  MOVFF  75,FE
1826:  MOVFF  74,FD
182A:  MOVFF  73,FC
182E:  MOVFF  72,FB
1832:  CALL   044E
1836:  MOVFF  03,7D
183A:  MOVFF  02,7C
183E:  MOVFF  01,7B
1842:  MOVFF  00,7A
....................               	        derr   = encVel - encVelOld; 
1846:  MOVF   xD1,W
1848:  SUBWF  xCD,W
184A:  MOVWF  00
184C:  MOVF   xD2,W
184E:  SUBWFB xCE,W
1850:  MOVWF  01
1852:  MOVF   xD3,W
1854:  SUBWFB xCF,W
1856:  MOVWF  02
1858:  MOVF   xD4,W
185A:  SUBWFB xD0,W
185C:  MOVWF  03
185E:  MOVWF  xFA
1860:  MOVFF  02,F9
1864:  MOVFF  01,F8
1868:  MOVFF  00,F7
186C:  CALL   03F8
1870:  MOVFF  03,81
1874:  MOVFF  02,80
1878:  MOVFF  01,7F
187C:  MOVFF  00,7E
....................           	         
....................          	            Vpid  = interr + error; 
1880:  BCF    FD8.1
1882:  MOVFF  85,FA
1886:  MOVFF  84,F9
188A:  MOVFF  83,F8
188E:  MOVFF  82,F7
1892:  MOVFF  7D,FE
1896:  MOVFF  7C,FD
189A:  MOVFF  7B,FC
189E:  MOVFF  7A,FB
18A2:  CALL   044E
18A6:  MOVFF  03,79
18AA:  MOVFF  02,78
18AE:  MOVFF  01,77
18B2:  MOVFF  00,76
....................           	            Vpid *= v_Ki; 
18B6:  MOVFF  79,FA
18BA:  MOVFF  78,F9
18BE:  MOVFF  77,F8
18C2:  MOVFF  76,F7
18C6:  MOVFF  8D,FE
18CA:  MOVFF  8C,FD
18CE:  MOVFF  8B,FC
18D2:  MOVFF  8A,FB
18D6:  CALL   02EE
18DA:  MOVFF  03,79
18DE:  MOVFF  02,78
18E2:  MOVFF  01,77
18E6:  MOVFF  00,76
....................           	            Vpid += v_Kp * error; 
18EA:  MOVFF  89,FA
18EE:  MOVFF  88,F9
18F2:  MOVFF  87,F8
18F6:  MOVFF  86,F7
18FA:  MOVFF  7D,FE
18FE:  MOVFF  7C,FD
1902:  MOVFF  7B,FC
1906:  MOVFF  7A,FB
190A:  CALL   02EE
190E:  BCF    FD8.1
1910:  MOVFF  79,FA
1914:  MOVFF  78,F9
1918:  MOVFF  77,F8
191C:  MOVFF  76,F7
1920:  MOVFF  03,FE
1924:  MOVFF  02,FD
1928:  MOVFF  01,FC
192C:  MOVFF  00,FB
1930:  CALL   044E
1934:  MOVFF  03,79
1938:  MOVFF  02,78
193C:  MOVFF  01,77
1940:  MOVFF  00,76
....................            	            Vpid += v_Kd * derr; 
1944:  MOVFF  91,FA
1948:  MOVFF  90,F9
194C:  MOVFF  8F,F8
1950:  MOVFF  8E,F7
1954:  MOVFF  81,FE
1958:  MOVFF  80,FD
195C:  MOVFF  7F,FC
1960:  MOVFF  7E,FB
1964:  CALL   02EE
1968:  BCF    FD8.1
196A:  MOVFF  79,FA
196E:  MOVFF  78,F9
1972:  MOVFF  77,F8
1976:  MOVFF  76,F7
197A:  MOVFF  03,FE
197E:  MOVFF  02,FD
1982:  MOVFF  01,FC
1986:  MOVFF  00,FB
198A:  CALL   044E
198E:  MOVFF  03,79
1992:  MOVFF  02,78
1996:  MOVFF  01,77
199A:  MOVFF  00,76
....................                     } 
....................                                   
....................         	        /* 
....................             	    if( Vpid < -1800.0  ) { 
....................             	        new_V = 1800.0; 
....................             	        new_dir = 0; 
....................             	    } else if( Vpid < 0 ) { 
....................                 	    interr  = interr + error; 
....................                 	    new_V = (int16) -Vpid; 
....................                 	    new_dir = 0; 
....................                 	} else if ( Vpid < 1800. ) { 
....................                     	interr  = interr + error; 
....................             	        new_V = (int16) Vpid; 
....................             	        new_dir = 1; 
....................             	    } else { 
....................                 	    new_V = 1800.0; 
....................                 	    new_dir = 1; 
....................                 	}   
....................                 	*/ 
....................           	        if( encVelRef_new == 0 && encVel == 0 ) { 
199E:  MOVFF  75,FE
19A2:  MOVFF  74,FD
19A6:  MOVFF  73,FC
19AA:  MOVFF  72,FB
19AE:  MOVLB  1
19B0:  CLRF   x02
19B2:  CLRF   x01
19B4:  CLRF   x00
19B6:  MOVLB  0
19B8:  CLRF   xFF
19BA:  CALL   08FC
19BE:  BNZ   19D8
19C0:  MOVF   xCD,F
19C2:  BNZ   19D8
19C4:  MOVF   xCE,F
19C6:  BNZ   19D8
19C8:  MOVF   xCF,F
19CA:  BNZ   19D8
19CC:  MOVF   xD0,F
19CE:  BNZ   19D8
....................               	        Vpid = 0; 
19D0:  CLRF   x79
19D2:  CLRF   x78
19D4:  CLRF   x77
19D6:  CLRF   x76
....................               	    } 
....................                   	     
....................                 	if( Vpid < 0 ) { 
19D8:  MOVFF  79,FE
19DC:  MOVFF  78,FD
19E0:  MOVFF  77,FC
19E4:  MOVFF  76,FB
19E8:  MOVLB  1
19EA:  CLRF   x02
19EC:  CLRF   x01
19EE:  CLRF   x00
19F0:  MOVLB  0
19F2:  CLRF   xFF
19F4:  CALL   08FC
19F8:  BNC   1A2A
....................                     	new_V = (int16) -Vpid; 
19FA:  MOVFF  76,00
19FE:  MOVF   x77,W
1A00:  XORLW  80
1A02:  MOVWF  01
1A04:  MOVFF  78,02
1A08:  MOVFF  79,03
1A0C:  MOVFF  79,FA
1A10:  MOVFF  78,F9
1A14:  MOVWF  xF8
1A16:  MOVFF  76,F7
1A1A:  CALL   0A0A
1A1E:  MOVFF  02,5B
1A22:  MOVFF  01,5A
....................                 	    new_dir = 0; 
1A26:  CLRF   5D
....................                     } else { 
1A28:  BRA    1A4A
....................                         new_V = (int16) Vpid; 
1A2A:  MOVFF  79,FA
1A2E:  MOVFF  78,F9
1A32:  MOVFF  77,F8
1A36:  MOVFF  76,F7
1A3A:  CALL   0A0A
1A3E:  MOVFF  02,5B
1A42:  MOVFF  01,5A
....................             	        new_dir = 1; 
1A46:  MOVLW  01
1A48:  MOVWF  5D
....................                     } 
....................                      
....................                     //Limite superior 
....................                     if( new_V > 1800 ) { 
1A4A:  BTFSC  5B.7
1A4C:  BRA    1A68
1A4E:  MOVF   5B,W
1A50:  SUBLW  06
1A52:  BC    1A68
1A54:  XORLW  FF
1A56:  BNZ   1A5E
1A58:  MOVF   5A,W
1A5A:  SUBLW  08
1A5C:  BC    1A68
....................                         new_V = 1800; 
1A5E:  MOVLW  07
1A60:  MOVWF  5B
1A62:  MOVLW  08
1A64:  MOVWF  5A
....................                     } else { 
1A66:  BRA    1ADA
....................                         if( h_pid_flag ) { 
1A68:  MOVF   xAA,F
1A6A:  BZ    1AA4
....................                             h_interr  = h_interr + h_error; 
1A6C:  BCF    FD8.1
1A6E:  MOVFF  9D,FA
1A72:  MOVFF  9C,F9
1A76:  MOVFF  9B,F8
1A7A:  MOVFF  9A,F7
1A7E:  MOVFF  95,FE
1A82:  MOVFF  94,FD
1A86:  MOVFF  93,FC
1A8A:  MOVFF  92,FB
1A8E:  CALL   044E
1A92:  MOVFF  03,9D
1A96:  MOVFF  02,9C
1A9A:  MOVFF  01,9B
1A9E:  MOVFF  00,9A
....................                         } else { 
1AA2:  BRA    1ADA
....................                             interr  = interr + error; 
1AA4:  BCF    FD8.1
1AA6:  MOVFF  85,FA
1AAA:  MOVFF  84,F9
1AAE:  MOVFF  83,F8
1AB2:  MOVFF  82,F7
1AB6:  MOVFF  7D,FE
1ABA:  MOVFF  7C,FD
1ABE:  MOVFF  7B,FC
1AC2:  MOVFF  7A,FB
1AC6:  CALL   044E
1ACA:  MOVFF  03,85
1ACE:  MOVFF  02,84
1AD2:  MOVFF  01,83
1AD6:  MOVFF  00,82
....................                         } 
....................                 	} 
....................                 	//Limite inferior (no cambia de direccion de giro) 
....................                 	if( m_dir != new_dir && encVel != 0 ){ 
1ADA:  MOVF   5D,W
1ADC:  SUBWF  5C,W
1ADE:  BZ    1AF8
1AE0:  MOVF   xCD,F
1AE2:  BNZ   1AF0
1AE4:  MOVF   xCE,F
1AE6:  BNZ   1AF0
1AE8:  MOVF   xCF,F
1AEA:  BNZ   1AF0
1AEC:  MOVF   xD0,F
1AEE:  BZ    1AF8
....................                       	m_V = 50; 
1AF0:  CLRF   59
1AF2:  MOVLW  32
1AF4:  MOVWF  58
....................                   	} else { 
1AF6:  BRA    1B04
....................                   	    m_V = new_V; 
1AF8:  MOVFF  5B,59
1AFC:  MOVFF  5A,58
....................                   	    m_dir = new_dir; 
1B00:  MOVFF  5D,5C
....................                     } 
....................       			    //CalcNextPWMDutyCicles(); 
....................       		        UpdatePWMDutyCycles();	   
1B04:  CALL   09A2
....................                     break; 
1B08:  BRA    1B6C
....................                 case STOP: 
....................                     m_V = 0; 
1B0A:  CLRF   59
1B0C:  CLRF   58
....................       		        if( encVel == 0 ) { 
1B0E:  MOVF   xCD,F
1B10:  BNZ   1B34
1B12:  MOVF   xCE,F
1B14:  BNZ   1B34
1B16:  MOVF   xCF,F
1B18:  BNZ   1B34
1B1A:  MOVF   xD0,F
1B1C:  BNZ   1B34
....................           			    interr     = 0; 
1B1E:  CLRF   x85
1B20:  CLRF   x84
1B22:  CLRF   x83
1B24:  CLRF   x82
....................       			        m_MtrCtrl  = PID; 
1B26:  MOVLW  03
1B28:  MOVWF  57
....................       			        if( goto_flag == 3 ) { 
1B2A:  MOVF   xEB,W
1B2C:  SUBLW  03
1B2E:  BNZ   1B34
....................           			        goto_flag = 1; 
1B30:  MOVLW  01
1B32:  MOVWF  xEB
....................           			    } 
....................       			    } 
....................                     UpdatePWMDutyCycles();  
1B34:  CALL   09A2
....................                     break; 
1B38:  BRA    1B6C
....................                 case STOPSLOWLY: 
....................                         
....................                     m_V= 0; 
1B3A:  CLRF   59
1B3C:  CLRF   58
....................                     /* 
....................                     if( m_V  > 10 ){ 
....................               	        m_V -= 20; 
....................     		        } else if( m_V < -10 ) { 
....................   	  			        m_V += 20; 
....................   			        } else { 
....................       			        m_V = 0; 
....................       			         
....................       			    }  
....................       			    */      
....................       			    if( encVel == 0 ) { 
1B3E:  MOVF   xCD,F
1B40:  BNZ   1B64
1B42:  MOVF   xCE,F
1B44:  BNZ   1B64
1B46:  MOVF   xCF,F
1B48:  BNZ   1B64
1B4A:  MOVF   xD0,F
1B4C:  BNZ   1B64
....................           			    h_interr   = 0; 
1B4E:  CLRF   x9D
1B50:  CLRF   x9C
1B52:  CLRF   x9B
1B54:  CLRF   x9A
....................       			        m_MtrCtrl  = PID; 
1B56:  MOVLW  03
1B58:  MOVWF  57
....................       			        if( goto_flag == 3 ) { 
1B5A:  MOVF   xEB,W
1B5C:  SUBLW  03
1B5E:  BNZ   1B64
....................           			        goto_flag = 1; 
1B60:  MOVLW  01
1B62:  MOVWF  xEB
....................           			    } 
....................       			    } 
....................       			    UpdatePWMDutyCycles();           
1B64:  CALL   09A2
....................                     break; 
1B68:  BRA    1B6C
....................   		        case IDLE: 
....................                     break; 
1B6A:  BRA    1B6C
....................             } 
....................  
.................... 	        //Updating old for next iteration 
.................... 	        encPosOld = encPos; 
1B6C:  MOVFF  DC,E0
1B70:  MOVFF  DB,DF
1B74:  MOVFF  DA,DE
1B78:  MOVFF  D9,DD
.................... 	        encVelOld = encVel; 
1B7C:  MOVFF  D0,D4
1B80:  MOVFF  CF,D3
1B84:  MOVFF  CE,D2
1B88:  MOVFF  CD,D1
.................... 	    } 
.................... 		 
....................         if( i2c_rx_flag  ) { 
1B8C:  MOVF   27,F
1B8E:  BTFSC  FD8.2
1B90:  BRA    1F00
....................             i2c_rx_flag = false; 
1B92:  CLRF   27
....................             if( mem_add < 8 ) { 
1B94:  MOVF   2F,W
1B96:  SUBLW  07
1B98:  BTFSS  FD8.0
1B9A:  BRA    1F00
....................                 data[mem_add] = * (signed int32 *) buffer; 
1B9C:  MOVF   2F,W
1B9E:  MULLW  04
1BA0:  MOVF   FF3,W
1BA2:  CLRF   03
1BA4:  ADDLW  31
1BA6:  MOVWF  01
1BA8:  MOVLW  00
1BAA:  ADDWFC 03,F
1BAC:  MOVFF  01,F7
1BB0:  MOVFF  03,F8
1BB4:  CLRF   xFA
1BB6:  MOVLW  2B
1BB8:  MOVWF  FE9
1BBA:  MOVFF  FA,FEA
1BBE:  MOVFF  FEF,00
1BC2:  MOVFF  FEC,01
1BC6:  MOVFF  FEC,02
1BCA:  MOVFF  FEC,03
1BCE:  MOVFF  F8,FEA
1BD2:  MOVFF  F7,FE9
1BD6:  MOVFF  00,FEF
1BDA:  MOVFF  01,FEC
1BDE:  MOVFF  02,FEC
1BE2:  MOVFF  03,FEC
....................                 if( mem_add == 0 ) { 
1BE6:  MOVF   2F,F
1BE8:  BNZ   1BF0
....................                     m_MtrCtrl = buffer[0]; 
1BEA:  MOVFF  2B,57
....................                 } else if( mem_add == 1 ) { 
1BEE:  BRA    1F00
1BF0:  DECFSZ 2F,W
1BF2:  BRA    1C58
....................                     X32 = * (signed int32 *) buffer; 
1BF4:  CLRF   xF8
1BF6:  MOVLW  2B
1BF8:  MOVWF  FE9
1BFA:  MOVFF  F8,FEA
1BFE:  MOVFF  FEF,00
1C02:  MOVFF  FEC,01
1C06:  MOVFF  FEC,02
1C0A:  MOVFF  FEC,03
1C0E:  MOVFF  03,F2
1C12:  MOVFF  02,F1
1C16:  MOVFF  01,F0
1C1A:  MOVFF  00,EF
....................                     if( X32 < 0  ){ 
1C1E:  BTFSC  xF2.7
1C20:  BRA    1C24
1C22:  BRA    1C48
....................                         p_Vfin = (int16) (- X32); 
1C24:  MOVLW  00
1C26:  BSF    FD8.0
1C28:  SUBFWB xEF,W
1C2A:  MOVWF  00
1C2C:  MOVLW  00
1C2E:  SUBFWB xF0,W
1C30:  MOVWF  01
1C32:  MOVLW  00
1C34:  SUBFWB xF1,W
1C36:  MOVLW  00
1C38:  SUBFWB xF2,W
1C3A:  MOVFF  01,55
1C3E:  MOVFF  00,54
....................                         p_dir = 1; 
1C42:  MOVLW  01
1C44:  MOVWF  56
....................                     } else {     
1C46:  BRA    1C52
....................                         p_Vfin= (int16) X32;     
1C48:  MOVFF  F0,55
1C4C:  MOVFF  EF,54
....................                         p_dir = 0;  
1C50:  CLRF   56
....................                     }  
....................                     m_MtrCtrl = NEWRAMPA;    
1C52:  MOVLW  04
1C54:  MOVWF  57
....................                 } else if( mem_add == 3 ) { 
1C56:  BRA    1F00
1C58:  MOVF   2F,W
1C5A:  SUBLW  03
1C5C:  BNZ   1CE0
....................                     X32 = * (signed int32 *) buffer; 
1C5E:  CLRF   xF8
1C60:  MOVLW  2B
1C62:  MOVWF  FE9
1C64:  MOVFF  F8,FEA
1C68:  MOVFF  FEF,00
1C6C:  MOVFF  FEC,01
1C70:  MOVFF  FEC,02
1C74:  MOVFF  FEC,03
1C78:  MOVFF  03,F2
1C7C:  MOVFF  02,F1
1C80:  MOVFF  01,F0
1C84:  MOVFF  00,EF
....................                      
....................                     if( X32 == 0 ) { 
1C88:  MOVF   xEF,F
1C8A:  BNZ   1C9E
1C8C:  MOVF   xF0,F
1C8E:  BNZ   1C9E
1C90:  MOVF   xF1,F
1C92:  BNZ   1C9E
1C94:  MOVF   xF2,F
1C96:  BNZ   1C9E
....................                         traking_flag = false; 
1C98:  CLRF   xE9
....................                         goto_tracking_flag = false; 
1C9A:  CLRF   xEA
....................                     } else { 
1C9C:  BRA    1CA4
....................                         traking_flag = true; 
1C9E:  MOVLW  01
1CA0:  MOVWF  xE9
....................                         goto_tracking_flag = true; 
1CA2:  MOVWF  xEA
....................                     } 
....................                     encTrkVel = (float) X32; 
1CA4:  MOVFF  F2,FA
1CA8:  MOVFF  F1,F9
1CAC:  MOVFF  F0,F8
1CB0:  MOVFF  EF,F7
1CB4:  CALL   03F8
1CB8:  MOVFF  03,69
1CBC:  MOVFF  02,68
1CC0:  MOVFF  01,67
1CC4:  MOVFF  00,66
....................                     avg = 0; 
1CC8:  CLRF   xE4
1CCA:  CLRF   xE3
1CCC:  CLRF   xE2
1CCE:  CLRF   xE1
....................                     n_avg = 1; 
1CD0:  CLRF   xE8
1CD2:  CLRF   xE7
1CD4:  CLRF   xE6
1CD6:  MOVLW  7F
1CD8:  MOVWF  xE5
....................                     m_MtrCtrl = NEWPID; 
1CDA:  MOVLW  02
1CDC:  MOVWF  57
....................                 } else if( mem_add == 4 ) { 
1CDE:  BRA    1F00
1CE0:  MOVF   2F,W
1CE2:  SUBLW  04
1CE4:  BTFSS  FD8.2
1CE6:  BRA    1E20
....................                     X32 = * (signed int32 *) buffer; 
1CE8:  CLRF   xF8
1CEA:  MOVLW  2B
1CEC:  MOVWF  FE9
1CEE:  MOVFF  F8,FEA
1CF2:  MOVFF  FEF,00
1CF6:  MOVFF  FEC,01
1CFA:  MOVFF  FEC,02
1CFE:  MOVFF  FEC,03
1D02:  MOVFF  03,F2
1D06:  MOVFF  02,F1
1D0A:  MOVFF  01,F0
1D0E:  MOVFF  00,EF
....................  
....................                     if( X32 < 0 ) { 
1D12:  BTFSC  xF2.7
1D14:  BRA    1D18
1D16:  BRA    1D32
....................                         encRev  = X32 - 3000; 
1D18:  MOVLW  B8
1D1A:  SUBWF  xEF,W
1D1C:  MOVWF  xC1
1D1E:  MOVLW  0B
1D20:  SUBWFB xF0,W
1D22:  MOVWF  xC2
1D24:  MOVLW  00
1D26:  SUBWFB xF1,W
1D28:  MOVWF  xC3
1D2A:  MOVLW  00
1D2C:  SUBWFB xF2,W
1D2E:  MOVWF  xC4
....................                     }  else { 
1D30:  BRA    1D42
....................                         encRev  = X32; 
1D32:  MOVFF  F2,C4
1D36:  MOVFF  F1,C3
1D3A:  MOVFF  F0,C2
1D3E:  MOVFF  EF,C1
....................                     } 
....................                     encRev /= 3000; 
1D42:  MOVFF  C4,FA
1D46:  MOVFF  C3,F9
1D4A:  MOVFF  C2,F8
1D4E:  MOVFF  C1,F7
1D52:  CLRF   xFE
1D54:  CLRF   xFD
1D56:  MOVLW  0B
1D58:  MOVWF  xFC
1D5A:  MOVLW  B8
1D5C:  MOVWF  xFB
1D5E:  GOTO   0A42
1D62:  MOVFF  03,C4
1D66:  MOVFF  02,C3
1D6A:  MOVFF  01,C2
1D6E:  MOVFF  00,C1
....................                      
....................                     encPos  = encRev; 
1D72:  MOVFF  C4,DC
1D76:  MOVFF  C3,DB
1D7A:  MOVFF  C2,DA
1D7E:  MOVFF  C1,D9
....................                     encPos *= 3000; 
1D82:  MOVFF  DC,FA
1D86:  MOVFF  DB,F9
1D8A:  MOVFF  DA,F8
1D8E:  MOVFF  D9,F7
1D92:  CLRF   xFE
1D94:  CLRF   xFD
1D96:  MOVLW  0B
1D98:  MOVWF  xFC
1D9A:  MOVLW  B8
1D9C:  MOVWF  xFB
1D9E:  CALL   0292
1DA2:  MOVFF  03,DC
1DA6:  MOVFF  02,DB
1DAA:  MOVFF  01,DA
1DAE:  MOVFF  00,D9
....................                     encPos  = X32 - encPos; 
1DB2:  MOVF   xD9,W
1DB4:  SUBWF  xEF,W
1DB6:  MOVWF  xD9
1DB8:  MOVF   xDA,W
1DBA:  SUBWFB xF0,W
1DBC:  MOVWF  xDA
1DBE:  MOVF   xDB,W
1DC0:  SUBWFB xF1,W
1DC2:  MOVWF  xDB
1DC4:  MOVF   xDC,W
1DC6:  SUBWFB xF2,W
1DC8:  MOVWF  xDC
....................                      
....................                     POSCNT  = (int32) encPos; 
1DCA:  MOVFF  DA,CA
1DCE:  MOVFF  D9,C9
....................                      
....................                     PIC_POSCNTL = * ( ( (char *) & POSCNT ) ); 
1DD2:  CLRF   xF8
1DD4:  MOVLW  C9
1DD6:  MOVWF  FE9
1DD8:  MOVFF  F8,FEA
1DDC:  MOVFF  FEF,F66
....................                     PIC_POSCNTH = * ( ( (char *) & POSCNT ) + 1 ); 
1DE0:  CLRF   xF8
1DE2:  MOVLW  C9
1DE4:  MOVWF  xF7
1DE6:  MOVLW  01
1DE8:  ADDWF  xF7,W
1DEA:  MOVWF  01
1DEC:  MOVLW  00
1DEE:  ADDWFC xF8,W
1DF0:  MOVFF  01,FE9
1DF4:  MOVWF  FEA
1DF6:  MOVFF  FEF,F67
....................                  
....................                     encPos = X32; 
1DFA:  MOVFF  F2,DC
1DFE:  MOVFF  F1,DB
1E02:  MOVFF  F0,DA
1E06:  MOVFF  EF,D9
....................                     encPosOld = encPos; 
1E0A:  MOVFF  DC,E0
1E0E:  MOVFF  DB,DF
1E12:  MOVFF  DA,DE
1E16:  MOVFF  D9,DD
....................                     m_MtrCtrl = STOP; 
1E1A:  MOVLW  08
1E1C:  MOVWF  57
....................     
....................                 } else if( mem_add == 6 ) { 
1E1E:  BRA    1F00
1E20:  MOVF   2F,W
1E22:  SUBLW  06
1E24:  BNZ   1E8C
....................                     X32 = * (signed int32 *) buffer; 
1E26:  CLRF   xF8
1E28:  MOVLW  2B
1E2A:  MOVWF  FE9
1E2C:  MOVFF  F8,FEA
1E30:  MOVFF  FEF,00
1E34:  MOVFF  FEC,01
1E38:  MOVFF  FEC,02
1E3C:  MOVFF  FEC,03
1E40:  MOVFF  03,F2
1E44:  MOVFF  02,F1
1E48:  MOVFF  01,F0
1E4C:  MOVFF  00,EF
....................    
....................                     m_MtrCtrl = NEWPID; 
1E50:  MOVLW  02
1E52:  MOVWF  57
....................                     encVelRef = (float) X32;               
1E54:  MOVFF  F2,FA
1E58:  MOVFF  F1,F9
1E5C:  MOVFF  F0,F8
1E60:  MOVFF  EF,F7
1E64:  CALL   03F8
1E68:  MOVFF  03,6D
1E6C:  MOVFF  02,6C
1E70:  MOVFF  01,6B
1E74:  MOVFF  00,6A
....................                     avg = 0; 
1E78:  CLRF   xE4
1E7A:  CLRF   xE3
1E7C:  CLRF   xE2
1E7E:  CLRF   xE1
....................                     n_avg = 1; 
1E80:  CLRF   xE8
1E82:  CLRF   xE7
1E84:  CLRF   xE6
1E86:  MOVLW  7F
1E88:  MOVWF  xE5
....................                      
....................                 } else if( mem_add == 7 ) { 
1E8A:  BRA    1F00
1E8C:  MOVF   2F,W
1E8E:  SUBLW  07
1E90:  BNZ   1F00
....................                     X32 = * (signed int32 *) buffer; 
1E92:  CLRF   xF8
1E94:  MOVLW  2B
1E96:  MOVWF  FE9
1E98:  MOVFF  F8,FEA
1E9C:  MOVFF  FEF,00
1EA0:  MOVFF  FEC,01
1EA4:  MOVFF  FEC,02
1EA8:  MOVFF  FEC,03
1EAC:  MOVFF  03,F2
1EB0:  MOVFF  02,F1
1EB4:  MOVFF  01,F0
1EB8:  MOVFF  00,EF
....................                     //diffPos = X32; 
....................                     trgPos  = encPos; 
1EBC:  MOVFF  DC,AE
1EC0:  MOVFF  DB,AD
1EC4:  MOVFF  DA,AC
1EC8:  MOVFF  D9,AB
....................                     trgPos += X32; 
1ECC:  MOVF   xEF,W
1ECE:  ADDWF  xAB,F
1ED0:  MOVF   xF0,W
1ED2:  ADDWFC xAC,F
1ED4:  MOVF   xF1,W
1ED6:  ADDWFC xAD,F
1ED8:  MOVF   xF2,W
1EDA:  ADDWFC xAE,F
....................                      
....................             
....................                     if( X32 == 0 ) { 
1EDC:  MOVF   xEF,F
1EDE:  BNZ   1EF0
1EE0:  MOVF   xF0,F
1EE2:  BNZ   1EF0
1EE4:  MOVF   xF1,F
1EE6:  BNZ   1EF0
1EE8:  MOVF   xF2,F
1EEA:  BNZ   1EF0
....................                         goto_flag = 0; 
1EEC:  CLRF   xEB
....................                     } else { 
1EEE:  BRA    1EFC
....................                         goto_flag = 1; 
1EF0:  MOVLW  01
1EF2:  MOVWF  xEB
....................                         trgThreshold = 0; 
1EF4:  CLRF   xB2
1EF6:  CLRF   xB1
1EF8:  CLRF   xB0
1EFA:  CLRF   xAF
....................                     } 
....................                     output_low( rLED ); 
1EFC:  BCF    F96.1
1EFE:  BCF    F8D.1
....................                 } 
....................             }     
....................         } 
....................  
....................         if( i2c_tx_flag ) { 
1F00:  MOVF   28,F
1F02:  BTFSC  FD8.2
1F04:  BRA    1FFA
....................             if( mem_add == 1 ) { 
1F06:  DECFSZ 2F,W
1F08:  BRA    1F30
....................                 data[1] = (signed int32) avg; 
1F0A:  MOVFF  E4,FA
1F0E:  MOVFF  E3,F9
1F12:  MOVFF  E2,F8
1F16:  MOVFF  E1,F7
1F1A:  GOTO   0B52
1F1E:  MOVFF  03,38
1F22:  MOVFF  02,37
1F26:  MOVFF  01,36
1F2A:  MOVFF  00,35
....................             } else if( mem_add == 2 ) { 
1F2E:  BRA    1FC6
1F30:  MOVF   2F,W
1F32:  SUBLW  02
1F34:  BNZ   1F4C
....................                 data[2] = POSCNT; 
1F36:  CLRF   02
1F38:  CLRF   03
1F3A:  MOVFF  03,3C
1F3E:  MOVFF  02,3B
1F42:  MOVFF  CA,3A
1F46:  MOVFF  C9,39
....................             } else if( mem_add == 3 ) { 
1F4A:  BRA    1FC6
1F4C:  MOVF   2F,W
1F4E:  SUBLW  03
1F50:  BNZ   1F64
....................                 data[3] = encRev; 
1F52:  MOVFF  C4,40
1F56:  MOVFF  C3,3F
1F5A:  MOVFF  C2,3E
1F5E:  MOVFF  C1,3D
....................             } else if( mem_add == 4 ) { 
1F62:  BRA    1FC6
1F64:  MOVF   2F,W
1F66:  SUBLW  04
1F68:  BNZ   1F7C
....................                 data[4] = encPos; 
1F6A:  MOVFF  DC,44
1F6E:  MOVFF  DB,43
1F72:  MOVFF  DA,42
1F76:  MOVFF  D9,41
....................             } else if( mem_add == 5 ) { 
1F7A:  BRA    1FC6
1F7C:  MOVF   2F,W
1F7E:  SUBLW  05
1F80:  BNZ   1F94
....................                 data[5] = encVel; 
1F82:  MOVFF  D0,48
1F86:  MOVFF  CF,47
1F8A:  MOVFF  CE,46
1F8E:  MOVFF  CD,45
....................             } else if( mem_add == 6 ) { 
1F92:  BRA    1FC6
1F94:  MOVF   2F,W
1F96:  SUBLW  06
1F98:  BNZ   1FB0
....................                 data[6] = (signed int32) m_V; 
1F9A:  CLRF   4C
1F9C:  CLRF   4B
1F9E:  MOVFF  59,4A
1FA2:  MOVFF  58,49
1FA6:  BTFSS  4A.7
1FA8:  BRA    1FAE
1FAA:  DECF   4B,F
1FAC:  DECF   4C,F
....................             } else if( mem_add == 7 ) { 
1FAE:  BRA    1FC6
1FB0:  MOVF   2F,W
1FB2:  SUBLW  07
1FB4:  BNZ   1FC6
....................                 data[7] = diffPos; 
1FB6:  MOVFF  B6,50
1FBA:  MOVFF  B5,4F
1FBE:  MOVFF  B4,4E
1FC2:  MOVFF  B3,4D
....................             }  
....................             pointer = (char *) & data[mem_add]; 
1FC6:  MOVF   2F,W
1FC8:  MULLW  04
1FCA:  MOVF   FF3,W
1FCC:  CLRF   03
1FCE:  ADDLW  31
1FD0:  MOVWF  51
1FD2:  MOVLW  00
1FD4:  ADDWFC 03,W
1FD6:  MOVWF  52
....................             WriteI2C( pointer[0] ); 
1FD8:  MOVFF  51,FE9
1FDC:  MOVFF  52,FEA
1FE0:  MOVFF  FEF,F7
1FE4:  CLRF   18
1FE6:  BTFSC  FF2.7
1FE8:  BSF    18.7
1FEA:  BCF    FF2.7
1FEC:  MOVFF  F7,108
1FF0:  CALL   00E4
1FF4:  BTFSC  18.7
1FF6:  BSF    FF2.7
....................             i2c_tx_flag = false; 
1FF8:  CLRF   28
....................         }    
....................          
....................     } 
1FFA:  GOTO   0DCC
.................... } 
1FFE:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 2E09   NOBROWNOUT WDT128 NOWDT BORV27 NOPUT NOWINEN
   Word  3: 953C   T1LOWPOWER HPOL_HIGH LPOL_HIGH PWMPIN MCLR FLTAC1 SSP_RC PWM4D5 EXCLKC3
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
