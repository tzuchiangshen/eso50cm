= Development of telescope control system for the 50cm telescope of the UC Santa Martina Observatory   = 

= Abstract 100 words = 

The main telescope of the UC Santa Martina Observatory is a 50cm optical telescope donated by ESO to Pontificia Univesidad Catolica de Chile. During the past years the telescope has been refurbished and used as the main facility for testing and validating new instruments under construction by the center of Astro-Engineering UC. As part of this work the need to develop a more efficient and flexible control system arises. The new distributed control system has been developed on top of Internet Communication Engine (ICE), a framework developed by Zeroc. The result of this work shows ICE as a real alternative for CORBA and other de facto distribute programming framework.

= Abstract 250 words = 

The main telescope of the UC Santa Martina Observatory is a 50cm optical telescope donated by ESO to Pontificia Univesidad Catolica de Chile. During the past years the telescope has been refurbished and used as the main facility for testing and validating new instruments under construction by the center of Astro-Engineering UC. As part of this work the need to develop a more efficient and flexible control system arises. The new distributed control system has been developed on top of Internet Communication Engine (ICE),  a framework developed by Zeroc Inc. This framework features a lightweight but powerful and flexible inter-process communication infrastructure and provides binding to classic and modern programming languages, such as, c/c++, java, c#, ruby-rail, objective c, etc. The result of this work shows ICE as a real alternative for CORBA and other de-facto distribute programming framework. A classical control software architecture has been chosen and comprises an observation control system (OCS), the orchestrator of  the observation, which controls the telescope control system (TCS), and detector control system (DCS). The real-time control and monitoring system is deployed and running over ARM based single board computers. Other features such as logging and configuration services have been developed as well. Inter-operation with other main astronomical control frameworks are foreseen in order achieve a smooth integration of instruments when they will be integrated in the main observatories in the north of Chile



= Introduction = 
(Pedro)
Brief summary Santa Martina Observatory and the role that ESO50cm plays within it. 

  * Educational telescope
  * Instrument testing and validation (PUCHEROS)

= ESO50cm  telescope = 
(Pedro)
<font color=red>
The ESO50cm is a equatorial mount telescope, manufactured by the end of 80ths. *...*
</font>

After the hardware refurbish, the telescope comprises of 3 encoders per motor in each axis. two of them are absolute encoders and one located in the worm is relative one. A low level PIC controller was created in order to read and interpret the encoders' gray code and to generate the PWM signal to drive the motors. The embedded PIC controller is controlled by another single board computer, together they form the Telescope Local Control Unit (LCU). One CCD camera is attached to the telescope with focus adjustment and the same light is split and redirected to the PUCHERO `[2]`, an spectrograph designed by the Department of Astro-Engineering [3]

In the following table relevant hardware are highlighted 
  * Equatorial mount telescope, 2 direct motors, 6 encoders (3 per axis)
  * TS-7800 ARM9 CPU, 512 Mb Ram. 
  * PIC18F422
  * CCD BIG6

= Software Architecture = 

== Key frameworks == 
*Summary of the selected technologies*

In the design of the control software for the telescope, the following base requirements were defined: 1) loosely coupled at subsystem level 2)be able to expose API to modern and mature programming languages, hopefully scripting languages and 3) allow incremental way to introduce new features or subsystems. 

After reviewing frameworks dominate in the astronomical software, such as ACS, VLT, TANGO, EPICS, ICE [2],[3]. The Internet Communication Engine (ICE) [1] framework was selected, not only because it fulfills the aforementioned requirements but also provides 1) support of distributed programming environment 2)binding to C++,.NET, Java, Python, Objective-C, Ruby, PHP programming languages, 3) mature and has reasonable size of community, 4) open source LGPL license and finally 4)lightweight and suitable for a small development team. This last point really make other framework forbidden for our team. The complexity of these frameworks are beyond our available resource. 

The source code are hosted at Google code [xx] repository, an simple but useful web application to host open source projects, with handy tools to generate documentations, release a new version of binaries, software version control, and source code browsing etc. SVN was selected as the official version control tool for this project.

Regarding to the build system system, we choose CMake [xx], a cross platform build system. Together with other homemade scripting tools, a clean build can be generated and deployed in a simple way, achievable through one single command line. CMake fulfills perfectly our needs to compile C++, Java code in Windows, i386 and ARM platforms, and it also provides support for scripting languages. Commands in CMake is expressive enough to define dependencies and invokes external code generation tools provided by ICE and QT. 

In order to be efficient in the GUI development, QT was chosen as the main framework. The signal/slot mechanism and the use of MVC pattern really help us to reach the high consistency and low coupling paradigm among our code. *talk about QT designer and QT creator*

To reduce testing time with the telescope, developers count on simulator to make progress, a telescope simulator was created by using QEMU, which provides support for ARM platform. In order to provide a common and clean development environment, virtual machines equivalent to the run time are created by using VirtualBox. 

In the following table we summarized the development and operation environment. 

<font color="red"> 
||Framwork|| Version ||
||ICE || version 3.4 ||
||QT  || version 4.3 ||

</font> 

== Logging Services == 
<font color=red>
(Johnny) 
  * pub/sub mechanism
  * persistence plugins (mysql, text)
</font>

== Subsystems == 
On top of the framework, a classical software architecture for telescope was chosen. It comprises a Telescope Control Subsystem (TCS), a Detector Control Subsystem (DCS), an Instrument Control Subsystem (ICS) and finally an Observation Coordination Subsystem (OCS) which coordinates the high level logic of an astronomical observation. 

http://eso50cm.googlecode.com/files/eso50cm%20control%20system.jpg

At hardware related subsystems (TCS, ICS, DCS), proper drivers were developed according to the specific hardware. At the same time, the required functionality is exposed through ICE interface. 

*add a container/component diagram*

ICE provides the ICE Slice tool .... *talk about the slice, and show lcu.ice* 

{{{ 
#ifndef LCU_ICE
#define LCU_ICE

module OUC 
{

enum TelescopeDirection {North, South, East, West};

...

interface LCU
{
    idempotent void sayHello(int delay);
    idempotent void shutdown();
  
    EncoderData getEncodersPosition()
         throws TelescopeNotConfiguredEx;
...	
    TelescopeData getPosition()
    	 throws TelescopeNotConfiguredEx;	
    bool isConfigured();
    bool isTracking();

    void setConfiguration(string fileName)
         throws NotConfigurationFileEx;
...
    void setTracking(TrackingInfo trkInfo);
    void parkTelescope();
    void stopTelescope(TelescopeDirection dir);
    void moveToTarget(); 
    void handsetSlew(SlewInfo slew);	 
};
};

}}}



===Telescope Control Subsystem (TCS)===
The telescope control subsystem was designated to cover all related aspects to the the movement (axis) and sky positioning (tracking) of telescope hardware and provide the high level interface to communicate with the rest of the subsystem (ICS, DCS, etc). TCS is compound of two process which receive instruction from the high level user through the OCS and communicate with the hardware to execute those instructions. Additionally a third process was implemented to simulate operations to be performed by the hardware: 
  * *lcuControl*: This process is in charge to collect the requests from the OCS and pass them to the hardware for the execution. This is a pure ICE process therefore the communication with the high level world is via TCP/IP by using ICE protocol. However, the communication with hardware is not direct since it sends the request to telescope61 process, which knows the hardware protocol to execute the instructions. Due to telescope61 is not an ICE process, the communication with lcuControl is through a shared memory which stores the requests and results of the hardware operations. Note that lcuControl and telescope61 runs under the same server (TS-7800)
  * *telescope61*: This process collect the request from the shared memory and send the instructions to the PIC18F422 interface, which communicate with the hardware by using RS232 protocol. Once executed an instruction, the results are stored in the share memory where lcuControl take the response and analyze the results. 
  * *telescope61-sim*:This process provide same functionality of telescope61 for reading request from the shared memory, however the commands are not passed to the hardware but software routines are implemented to emulate hardware behavior. It was implemented as a response to continue the development of high level applications without the restriction for accessing to the real hardware.
  
The following diagram show the interaction between TCS processes and the the other actors involved:

http://eso50cm.googlecode.com/files/interaction-sta-martina2.png

===Observation Coordination System (OCS)===
The OCS was designated as the coordinator between the different subsystems (TCS, ICS, DCS, etc). The astronomical observation is 100% controlled by this subsystem which is responsible to execute every instruction in a coherent way. This subsystem is compound by the main coordinator process and the high level interfaces which communicates the end users with the whole system:
  * *obsControl*: This process contains the public interfaces to communicate with the rest of the subsystems. For example it contains methods to move, track, stop, apply offset to the telescope. Other subsystem also send request to this process and it is in charge to distribute to the correct subsystem. High level interfaces (GUIs) should communicate exclusively with this process. Only engineering interfaces are allowed to communicate directly with the subsystems. 
  * *TcsGui*: 
  * *qths* :  


<font color=red>
  * telescope61 (Ruben) telescope61-sim (Tzu)
    * share memory 
    * communication with hardware 
  * ObsControl, TcsGui, qths  (MVC)
</font>
= Future Challenges = 
  * Integration of CCD, Auto guiding 
  * Interface to Labviw for hardware control 
  * Integration of pointing model (get rid of theSky6)
  * Package of the final observation data into a FITS format

= Conclusion = 
  * ICE framework is a mature distribute programming framework suitable for mission critical application.
  * TS-7800 ARM has proved to be a very robust platform for local control unit development
  * Reuse of software developed by big observatories in educational environment. 
 

= References = 
  * [1] referencia a Astro-ingenieria o el Observatorio UC
  * [2] ICE: http://www.zeroc.com/ice.html
  * [3] S. Shumko, "Ice middleware in the New Solar Telescope’s Telescope Control System", ADASS XVII, 2008
  * [4] J.C. Guzman, "Preliminary Design of the Australian SKA PathFinder  Telescope Control System", ICALEPCS 2009, Kobe, Japan
  * [5] referencia a un paper del PUCHEROS
  * [6] VLT Software Design 